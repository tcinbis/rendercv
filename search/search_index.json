{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"RenderCV","text":"<p>RenderCV is a $\\LaTeX$ CV/resume generator from a JSON/YAML input file. The primary motivation behind the RenderCV is to allow the separation between the content and design of a CV. If you want to see RenderCV in action, you can check out this YouTube video.</p> <p>It takes a YAML file that looks like this:</p> <pre><code>cv:\n  name: John Doe\n  location: Your Location\n  email: youremail@yourdomain.com\n  phone: tel:+90-541-999-99-99\n  website: https://yourwebsite.com/\n  social_networks:\n    - network: LinkedIn\n      username: yourusername\n    - network: GitHub\n      username: yourusername\n  sections:\n    summary:\n      - This is an example resume to showcase the capabilities\n        of the open-source LaTeX CV generator, [RenderCV](https://github.com/sinaatalay/rendercv).\n        A substantial part of the content is taken from [here](https://www.careercup.com/resume),\n        where a *clean and tidy CV* pattern is proposed by **Gayle\n        L. McDowell**.\n    education:\n      - start_date: 2000-09\n        end_date: 2005-05\n        highlights:\n          - 'GPA: 3.9/4.0 ([Transcript](https://example.com))'\n          - '**Coursework:** Software Foundations, Computer Architecture,\n            Algorithms, Artificial Intelligence, Comparison of\n            Learning Algorithms, Computational Theory.'\n        institution: University of Pennsylvania\n        area: Computer Science\n        degree: BS\n    experience:\n    ...\n</code></pre> <p>And then produces these PDFs and their $\\LaTeX$ code (click on images to preview PDFs):</p> <code>classic</code> theme <code>sb2nov</code> theme <code>moderncv</code> theme <p>It also generates an HTML file so that the content can be pasted into Grammarly for spell-checking:</p> <p></p> <p>RenderCV also validates the input file, and if there are any problems, it tells users where the issues are and how they can fix them:</p> <p></p>"},{"location":"#quick-start-guide","title":"Quick Start Guide","text":"<p>RenderCV doesn't require a $\\LaTeX$ installation; it comes with it!</p> <ol> <li>Install Python (3.10 or newer).</li> <li>Run the command below to install RenderCV.     <pre><code>pip install rendercv\n</code></pre></li> <li>Run the command below to generate a starting input file (<code>Full_Name_CV.yaml</code>).     <pre><code>rendercv new \"Full Name\"\n</code></pre></li> <li>Edit the contents of <code>Full_Name_CV.yaml</code> in your favorite editor (tip: use an editor that supports JSON Schemas).</li> <li>Run the command below to generate your $\\LaTeX$ CV.     <pre><code>rendercv render Full_Name_CV.yaml\n</code></pre></li> </ol> <p>You can find a comprehensive user guide that covers the data model (YAML structure) and adding custom themes in greater detail here.</p>"},{"location":"#motivation","title":"Motivation","text":"<p>Writing the content of a CV and designing a CV are separate issues, and they should be treated separately. RenderCV attempts to provide this separation. With this approach, users are encouraged not to worry too much about the appearance of their CV but to concentrate on the content.</p> <p>You can automatize your CV generation process with RenderCV and version control your CV in a well-structured manner. It will make updating your CV as simple as updating the YAML input file.</p> <p>Here are some answers to frequently asked questions about RenderCV:</p>"},{"location":"#why-should-i-bother-using-rendercv-instead-of-latex-i-can-version-control-latex-code-too","title":"Why should I bother using RenderCV instead of $\\LaTeX$? I can version-control $\\LaTeX$ code too!","text":"<p>Because:</p> <ul> <li>RenderCV is a tool that allows you to separate your CV content from your $\\LaTeX$ code. $\\LaTeX$ is still there, and you can leverage it by moving your custom $\\LaTeX$ CV to RenderCV.</li> <li>You might want to version control the content and design of your CV separately without mixing them into each other. You cannot achieve this with $\\LaTeX$. If you have a plain $\\LaTeX$ CV, changing your design will require you to do almost everything from scratch.</li> <li>Updating a YAML file may be easier than updating a $\\LaTeX$ file.</li> <li>You will have a lot of code duplication if you make your CV in $\\LaTeX$ because a CV is a list of sections with lists of entries. With RenderCV, you will have only one $\\LaTeX$ code for each entry type, which will be duplicated automatically based on the YAML input.</li> <li>Spell checking may be difficult to do in $\\LaTeX$. You will need to copy and paste each sentence separately to some other software for spell-checking. With RenderCV, it's one copy-paste.</li> </ul>"},{"location":"#is-it-flexible-enough","title":"Is it flexible enough?","text":"<p>RenderCV gives you the flexibility required for a CV, but not more. RenderCV forces users to be strict about the content of their CVs, and that's helpful! A CV is a strict and structured document, and you may not want to change that strictness arbitrarily.</p> <p>You can't make design mistakes with RenderCV, but you can be flexible enough. It supports Markdown syntax, so you can put links anywhere or make your text italic or bold. Additionally, you can specify various design options (margins, colors, font sizes, etc.) in your input file's <code>design</code> section.</p>"},{"location":"#isnt-putting-all-of-my-data-into-a-yaml-file-cumbersome","title":"Isn't putting all of my data into a YAML file cumbersome?","text":"<p>If you do it for RenderCV once, you may not have to do it again for a long time. It will help you to avoid this process in the future.</p>"},{"location":"#documentation","title":"Documentation","text":"<p>The source code of RenderCV is well-commented and documented. Reading the source code might be fun as the software structure is explained with docstrings and comments.</p> <p>A detailed user guide can be found here.</p> <p>Reference to the code can be found here.</p> <p>The changelog can be found here.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>All contributions to RenderCV are welcome! For development, you will need to clone the repository recursively, as TinyTeX is being used as a submodule:</p> <pre><code>git clone --recursive https://github.com/sinaatalay/rendercv.git\n</code></pre> <p>All code and development tool specifications are in <code>pyproject.toml</code>.</p>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog.</p> <p>Click here to see the unreleased changes.</p>"},{"location":"changelog/#16-2024-03-31","title":"1.6 - 2024-03-31","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>A new theme has been added: <code>engineeringresumes</code>. It hasn't been tested fully yet.</li> <li>A new text alignment option has been added to <code>classic</code> and <code>sb2nov</code>: <code>justified-with-no-hyphenation</code> (#34)</li> <li>Users are now allowed to run local <code>lualatex</code>, <code>xelatex</code>, <code>latexmk</code> commands in addition to <code>pdflatex</code> (#48).</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Orcid is now displayed in the header like other social media links.</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Decoding issues have been fixed (#29).</li> <li>Classic theme's <code>ExperienceEntry</code> has been fixed (#49).</li> </ul>"},{"location":"changelog/#15-2024-03-27","title":"1.5 - 2024-03-27","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Users can now make bold or italic texts normal with Markdown syntax.</li> </ul>"},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>The <code>moderncv</code> theme doesn't italicize any text by default now.</li> </ul>"},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>The <code>moderncv</code> theme's PDF title issue has been fixed.</li> <li>The ordering of the data models' keys in JSON Schema has been fixed.</li> <li>The unhandled exception when a custom theme's <code>__init__.py</code> file is invalid has been fixed.</li> <li>The <code>sb2nov</code> theme's <code>PublicationEntry</code> without <code>journal</code> and <code>doi</code> fields is now rendered correctly.</li> <li>The <code>sb2nov</code> theme's <code>OneLineEntry</code>'s colon issue has been fixed.</li> </ul>"},{"location":"changelog/#14-2024-03-10","title":"1.4 - 2024-03-10","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>A new entry type has been added: <code>BulletEntry</code></li> </ul>"},{"location":"changelog/#changed_2","title":"Changed","text":"<ul> <li><code>OneLineEntry</code>'s <code>name</code> field has been changed to <code>label</code>. This was required to generalize the entry validations.</li> <li><code>moderncv</code>'s highlights are now bullet points.</li> <li><code>moderncv</code>'s <code>TextEntries</code> don't have bullet points anymore.</li> <li><code>sb2nov</code>'s <code>TextEntries</code> don't have bullet points anymore.</li> </ul>"},{"location":"changelog/#13-2024-03-09","title":"1.3 - 2024-03-09","text":""},{"location":"changelog/#added_3","title":"Added","text":"<ul> <li>CLI documentation has been added to the user guide.</li> </ul>"},{"location":"changelog/#changed_3","title":"Changed","text":"<ul> <li>Future dates are now allowed.</li> <li>Authors' first names are no longer abbreviated in <code>PublicationEntry</code>.</li> <li>Markdown is now supported in the <code>authors</code> field of <code>PublicationEntry</code>.</li> <li><code>doi</code> field is now optional for <code>PublicationEntry</code>.</li> </ul>"},{"location":"changelog/#fixed_2","title":"Fixed","text":"<ul> <li>The <code>journal</code> is now displayed in the <code>PublicationEntry</code> of the <code>sb2nov</code> theme.</li> </ul>"},{"location":"changelog/#12-2024-02-27","title":"1.2 - 2024-02-27","text":""},{"location":"changelog/#fixed_3","title":"Fixed","text":"<ul> <li>Markdown <code>TextEntry</code>, where all the paragraphs were concatenated into a single paragraph, has been fixed.</li> <li>Markdown <code>OneLineEntry</code>, where all the one-line entries were concatenated into a single line, has been fixed.</li> <li>The <code>classic</code> theme's <code>PublicationEntry</code>, where blank parentheses were rendered when the <code>journal</code> field was not provided, has been fixed.</li> <li>A bug, where an email with special characters caused a LaTeX error, has been fixed.</li> <li>Unicode error, when <code>rendercv new</code> is called with a name with special characters, has been fixed.</li> </ul>"},{"location":"changelog/#11-2024-02-25","title":"1.1 - 2024-02-25","text":""},{"location":"changelog/#added_4","title":"Added","text":"<ul> <li>RenderCV is now a $\\LaTeX$ CV framework. Users can move their $\\LaTeX$ CV themes to RenderCV to produce their CV from RenderCV's YAML input.</li> <li>RenderCV now generates Markdown and HTML versions of the CV to allow users to paste the content of the CV to another software (like Grammarly) for spell checking.</li> <li>A new theme has been added: <code>moderncv</code>.</li> <li>A new theme has been added: <code>sb2nov</code>.</li> </ul>"},{"location":"changelog/#changed_4","title":"Changed","text":"<ul> <li>The data model has been changed to be more flexible. All the sections are now under the <code>sections</code> field. All the keys are arbitrary and rendered as section titles. The entry types can be any of the six built-in entry types, and they will be detected by RenderCV for each section.</li> <li>The templating system has been changed completely.</li> <li>The command-line interface (CLI) has been improved.</li> <li>The validation error messages have been improved.</li> <li>TinyTeX has been moved to another repository, and it is being pulled as a Git submodule. It is still pushed to PyPI, but it's not a part of the repository anymore.</li> <li>Tests have been improved, and it uses <code>pytest</code> instead of <code>unittest</code>.</li> <li>The documentation has been rewritten.</li> <li>The reference has been rewritten.</li> <li>The build system has been changed from <code>setuptools</code> to <code>hatchling</code>.</li> </ul>"},{"location":"changelog/#010-2023-11-29","title":"0.10 - 2023-11-29","text":""},{"location":"changelog/#fixed_4","title":"Fixed","text":"<ul> <li>Author highlighting issue has been fixed in <code>PublicationEntry</code>.</li> </ul>"},{"location":"changelog/#09-2023-11-29","title":"0.9 - 2023-11-29","text":""},{"location":"changelog/#added_5","title":"Added","text":"<ul> <li>Page numbering has been added.</li> <li>Text alignment options have been added (left-aligned or justified).</li> <li>Header options have been added (margins and header font size).</li> <li><code>university_projects</code> field has been added.</li> </ul>"},{"location":"changelog/#08-2023-11-17","title":"0.8 - 2023-11-17","text":""},{"location":"changelog/#fixed_5","title":"Fixed","text":"<ul> <li>YYYY date issue has been solved (#5).</li> </ul>"},{"location":"changelog/#07-2023-11-03","title":"0.7 - 2023-11-03","text":""},{"location":"changelog/#changed_5","title":"Changed","text":"<ul> <li>The date type has been improved. It supports <code>YYYY-MM-DD</code>, <code>YYYY-MM</code>, and <code>YYYY</code> formats now.</li> </ul>"},{"location":"changelog/#fixed_6","title":"Fixed","text":"<ul> <li>Custom sections' error messages have been fixed.</li> </ul>"},{"location":"changelog/#06-2023-10-28","title":"0.6 - 2023-10-28","text":""},{"location":"changelog/#added_6","title":"Added","text":"<ul> <li>New fields have been added: <code>experience</code>, <code>projects</code>, <code>awards</code>, <code>interests</code>, and <code>programming_skills</code>.</li> </ul>"},{"location":"changelog/#fixed_7","title":"Fixed","text":"<ul> <li>DOI validation bug has been fixed by @LabAsim in #3/</li> </ul>"},{"location":"changelog/#05-2023-10-27","title":"0.5 - 2023-10-27","text":""},{"location":"changelog/#added_7","title":"Added","text":"<ul> <li>Orcid support has been added.</li> </ul>"},{"location":"changelog/#fixed_8","title":"Fixed","text":"<ul> <li>Special $\\LaTeX$ characters' escaping has been fixed.</li> </ul>"},{"location":"changelog/#04-2023-10-22","title":"0.4 - 2023-10-22","text":""},{"location":"changelog/#changed_6","title":"Changed","text":"<ul> <li>CLI has been improved for more intuitive validation error messages.</li> </ul>"},{"location":"changelog/#03-2023-10-20","title":"0.3 - 2023-10-20","text":""},{"location":"changelog/#fixed_9","title":"Fixed","text":"<ul> <li>The colors of CLI output have been fixed.</li> <li>Encoding problems have been fixed.</li> </ul>"},{"location":"changelog/#02-2023-10-17","title":"0.2 - 2023-10-17","text":""},{"location":"changelog/#fixed_10","title":"Fixed","text":"<ul> <li>MacOS compatibility issues have been fixed.</li> </ul>"},{"location":"changelog/#01-2023-10-15","title":"0.1 - 2023-10-15","text":"<p>The first release of RenderCV.</p>"},{"location":"user_guide/","title":"RenderCV: User Guide","text":"<p>This document provides everything you need to know about the usage of RenderCV.</p>"},{"location":"user_guide/#installation","title":"Installation","text":"<p>RenderCV doesn't require a $\\LaTeX$ installation; it comes with it!</p> <ol> <li> <p>Install Python (3.10 or newer).</p> </li> <li> <p>Run the command below to install RenderCV.</p> </li> </ol> <pre><code>pip install rendercv\n</code></pre> <p>or</p> <pre><code>python -m pip install rendercv\n</code></pre>"},{"location":"user_guide/#generating-the-input-file","title":"Generating the input file","text":"<p>To get started, navigate to the directory where you want to create your CV and run the command below to create the input file.</p> <pre><code>rendercv new \"Your Full Name\"\n</code></pre> <p>or</p> <pre><code>python -m rendercv new \"Your Full Name\"\n</code></pre> <p>This will create a YAML input file for RenderCV called <code>Your_Name_CV.yaml</code>. Open this file in your favorite IDE and start editing.</p> <p>Tip</p> <p>To maximize your productivity while editing the input YAML file, set up RenderCV's JSON Schema in your IDE. It will validate your inputs on the fly and give auto-complete suggestions.</p> Visual Studio CodeOther <ol> <li>Install YAML language support extension.</li> <li>Then the Schema will be automatically set up because the file ends with <code>_CV.yaml</code>.</li> </ol> <ol> <li>Ensure your editor of choice has support for JSON Schema.</li> <li> <p>Add the following line at the top of <code>Your_Name_CV.yaml</code>:</p> <pre><code># yaml-language-server: $schema=https://github.com/sinaatalay/rendercv/blob/main/schema.json?raw=true\n</code></pre> </li> </ol>"},{"location":"user_guide/#the-yaml-structure-of-the-input-file","title":"The YAML structure of the input file","text":"<p>RenderCV's input file consists of two parts: <code>cv</code> and <code>design</code>.</p> <pre><code>cv:\n  ...\n  YOUR CONTENT\n  ...\ndesign:\n  ...\n  YOUR DESIGN\n  ...\n</code></pre> <p>The <code>cv</code> part contains only the content of the CV, and the <code>design</code> part contains only the design options of the CV. That's how the design and content are separated.</p>"},{"location":"user_guide/#cv-section-of-the-yaml-input","title":"\"<code>cv</code>\" section of the YAML input","text":"<p>The <code>cv</code> section of the YAML input starts with generic information, as shown below:</p> <pre><code>cv:\n  name: John Doe\n  location: Your Location\n  email: youremail@yourdomain.com\n  phone: tel:+90-541-999-99-99\n  website: https://yourwebsite.com/\n  social_networks:\n    - network: LinkedIn\n      username: yourusername\n    - network: GitHub\n      username: yourusername\n  ...\n</code></pre> <p>None of the values above are required. You can omit any or all of them, and RenderCV will adapt to your input.</p> <p>The main content of your CV is stored in a field called sections.</p> <pre><code>cv:\n  name: John Doe\n  location: Your Location\n  email: youremail@yourdomain.com\n  phone: tel:+90-541-999-99-99\n  website: https://yourwebsite.com/\n  social_networks:\n    - network: LinkedIn\n      username: yourusername\n    - network: GitHub\n      username: yourusername\n  sections:\n    ...\n    YOUR CONTENT\n    ...\n</code></pre> <p>The <code>sections</code> field is a dictionary where the keys are the section titles, and the values are lists. Each item of the list is an entry for that section.</p> <p>Here is an example:</p> <pre><code>cv:\n  sections:\n    this_is_a_section_title:\n      - This is a TextEntry.\n      - This is another TextEntry under the same section.\n      - This is another another TextEntry under the same section.\n    this_is_another_section_title:\n      - company: This time it's an ExperienceEntry.\n        position: Your position\n        start_date: 2019-01-01\n        end_date: 2020-01\n        location: TX, USA\n        highlights: \n          - This is a highlight (bullet point).\n          - This is another highlight.\n      - company: Another ExperienceEntry.\n        position: Your position\n        start_date: 2019-01-01\n        end_date: 2020-01-10\n        location: TX, USA\n        highlights: \n          - This is a highlight (bullet point).\n          - This is another highlight.\n</code></pre> <p>There are six different entry types in RenderCV. Different types of entries cannot be mixed under the same section, so for each section, you can only use one type of entry.</p> <p>The available entry types are: <code>EducationEntry</code>, <code>ExperienceEntry</code>, <code>PublicationEntry</code>, <code>NormalEntry</code>, <code>OneLineEntry</code>, and <code>TextEntry</code>.</p> <p>Each entry type is a different object (a dictionary). All of the entry types and their corresponding look in each built-in theme are shown below:</p>"},{"location":"user_guide/#education-entry","title":"Education Entry","text":"<pre><code>institution: Bo\u011fazi\u00e7i University\nlocation: Istanbul, Turkey\ndegree: BS\narea: Mechanical Engineering\nstart_date: 2015-09\nend_date: 2020-06\nhighlights:\n  - 'GPA: 3.24/4.00 ([Transcript](https://example.com))'\n  - \"Awards: Dean's Honor List, Sportsperson of the Year\"\n</code></pre> <p><code>classic</code> theme: </p> <p><code>moderncv</code> theme: </p> <p><code>sb2nov</code> theme: </p> <p><code>engineeringresumes</code> theme: </p>"},{"location":"user_guide/#experience-entry","title":"Experience Entry","text":"<pre><code>company: Some Company\nlocation: TX, USA\nposition: Software Engineer\nstart_date: 2020-07\nend_date: '2021-08-12'\nhighlights:\n  - Developed an [IOS application](https://example.com) that has\n    received more than **100,000 downloads**.\n  - Managed a team of **5** engineers.\n</code></pre> <p><code>classic</code> theme: </p> <p><code>moderncv</code> theme: </p> <p><code>sb2nov</code> theme: </p> <p><code>engineeringresumes</code> theme: </p>"},{"location":"user_guide/#normal-entry","title":"Normal Entry","text":"<pre><code>name: Some Project\nlocation: Remote\ndate: 2021-09\nhighlights:\n  - Developed a web application with **React** and **Django**.\n  - Implemented a **RESTful API**\n</code></pre> <p><code>classic</code> theme: </p> <p><code>moderncv</code> theme: </p> <p><code>sb2nov</code> theme: </p> <p><code>engineeringresumes</code> theme: </p>"},{"location":"user_guide/#publication-entry","title":"Publication Entry","text":"<pre><code>title: Magneto-Thermal Thin Shell Approximation for 3D Finite\n  Element Analysis of No-Insulation Coils\nauthors:\n  - J. Doe\n  - '***H. Tom***'\n  - S. Doe\n  - A. Andsurname\ndate: '2021-12-08'\njournal: IEEE Transactions on Applied Superconductivity\ndoi: 10.1109/TASC.2023.3340648\n</code></pre> <p><code>classic</code> theme: </p> <p><code>moderncv</code> theme: </p> <p><code>sb2nov</code> theme: </p> <p><code>engineeringresumes</code> theme: </p>"},{"location":"user_guide/#one-line-entry","title":"One Line Entry","text":"<pre><code>label: Programming\ndetails: Python, C++, JavaScript, MATLAB\n</code></pre> <p><code>classic</code> theme: </p> <p><code>moderncv</code> theme: </p> <p><code>sb2nov</code> theme: </p> <p><code>engineeringresumes</code> theme: </p>"},{"location":"user_guide/#bullet-entry","title":"Bullet Entry","text":"<pre><code>bullet: This is a bullet entry.\n</code></pre> <p><code>classic</code> theme: </p> <p><code>moderncv</code> theme: </p> <p><code>sb2nov</code> theme: </p> <p><code>engineeringresumes</code> theme: </p>"},{"location":"user_guide/#text-entry","title":"Text Entry","text":"<pre><code>This is a *TextEntry*. It is only a text and can be useful for\nsections like **Summary**. To showcase the TextEntry completely,\nthis sentence is added, but it doesn't contain any information.\n...\n</code></pre> <p><code>classic</code> theme: </p> <p><code>moderncv</code> theme: </p> <p><code>sb2nov</code> theme: </p> <p><code>engineeringresumes</code> theme: </p>"},{"location":"user_guide/#design-section-of-the-yaml-input","title":"\"<code>design</code>\" section of the YAML input","text":"<p>The <code>cv</code> part of the input contains your content, and the <code>design</code> part contains your design. The <code>design</code> part starts with a theme name. Currently, there are three built-in themes (<code>classic</code>, <code>sb2nov</code>, and <code>moderncv</code>), but custom themes can also be used (see below.)</p> <pre><code>design:\n  theme: classic\n  ...\n</code></pre> <p>Each theme has different options for design. <code>classic</code> and <code>sb2nov</code> almost use identical options, but <code>moderncv</code> is slightly different. Please use an IDE that supports JSON schema to avoid missing any available options for the theme (see above).</p> <p>An example <code>design</code> part for a <code>classic</code> theme is shown below:</p> <pre><code>design:\n  theme: classic\n  color: rgb(0,79,144)\n  disable_page_numbering: false\n  font_size: 10pt\n  header_font_size: 30 pt\n  page_numbering_style: NAME - Page PAGE_NUMBER of TOTAL_PAGES\n  page_size: a4paper\n  show_last_updated_date: true\n  text_alignment: justified\n  margins: \n    page:\n      bottom: 2 cm\n      left: 1.24 cm\n      right: 1.24 cm\n      top: 2 cm\n    section_title:\n      bottom: 0.2 cm\n      top: 0.2 cm\n    entry_area:\n      date_and_location_width: 4.1 cm\n      left_and_right: 0.2 cm\n      vertical_between: 0.12 cm\n    highlights_area:\n      left: 0.4 cm\n      top: 0.10 cm\n      vertical_between_bullet_points: 0.10 cm\n    header:\n      bottom: 0.2 cm\n      horizontal_between_connections: 1.5 cm\n      vertical_between_name_and_connections: 0.2 cm\n</code></pre>"},{"location":"user_guide/#command-line-interface-cli","title":"Command-line interface (CLI)","text":"<p>Currently, RenderCV has two command-line interface functions: <code>new</code>, and <code>render</code>.</p>"},{"location":"user_guide/#rendercv-new","title":"<code>rendercv new</code>","text":"<p><code>rendercv new YOUR_FULL_NAME</code> generates a sample YAML input file to get started. An optional <code>theme</code> input allows you to generate a YAML file for a specific built-in theme.</p> <pre><code>rendercv new --theme THEME_NAME \"John Doe\"\n</code></pre>"},{"location":"user_guide/#rendercv-render","title":"<code>rendercv render</code>","text":"<p><code>rendercv render INPUT_FILE_PATH</code> renders the given YAML input file. An optional <code>use-local-latex-command</code> option can be used to generate the CV with the local LaTeX installation.</p> <pre><code>rendercv render --use-local-latex-command pdflatex John_Doe_CV.yaml\n</code></pre>"},{"location":"user_guide/#using-custom-themes","title":"Using custom themes","text":"<p>RenderCV allows you to move your $\\LaTeX$ CV code to RenderCV. To do this, you will need to create some files:</p> <pre><code>\u251c\u2500\u2500 yourcustomtheme\n\u2502   \u251c\u2500\u2500 Preamble.j2.tex\n\u2502   \u251c\u2500\u2500 Header.j2.tex\n\u2502   \u251c\u2500\u2500 EducationEntry.j2.tex\n\u2502   \u251c\u2500\u2500 ExperienceEntry.j2.tex\n\u2502   \u251c\u2500\u2500 NormalEntry.j2.tex\n\u2502   \u251c\u2500\u2500 OneLineEntry.j2.tex\n\u2502   \u251c\u2500\u2500 PublicationEntry.j2.tex\n\u2502   \u251c\u2500\u2500 TextEntry.j2.tex\n\u2502   \u251c\u2500\u2500 SectionBeginning.j2.tex\n\u2502   \u2514\u2500\u2500 SectionEnding.j2.tex\n\u2514\u2500\u2500 Your_Full_Name_CV.yaml\n</code></pre> <p>Each of these <code>*.j2.tex</code> files is $\\LaTeX$ code with some Python in it. These files allow RenderCV to create your CV out of the YAML input.</p> <p>The best way to understand how they work is to look at the source code of built-in themes. For example, the content of <code>ExperienceEntry.j2.tex</code> for the <code>moderncv</code> theme is shown below:</p> <pre><code>\\cventry{\n    ((* if design.show_only_years *))\n    &lt;&lt;entry.date_string_only_years&gt;&gt;\n    ((* else *))\n    &lt;&lt;entry.date_string&gt;&gt;\n    ((* endif *))\n}{\n    &lt;&lt;entry.position&gt;&gt;\n}{\n    &lt;&lt;entry.company&gt;&gt;\n}{\n    &lt;&lt;entry.location&gt;&gt;\n}{}{}\n((* for item in entry.highlights *))\n\\cvline{}{\\small &lt;&lt;item&gt;&gt;}\n((* endfor *))\n</code></pre> <p>The values between <code>&lt;&lt;</code> and <code>&gt;&gt;</code> are the names of Python variables, allowing you to write a $\\LaTeX$ CV without writing any content. Those will be replaced with the values found in the YAML input. Also, the values between <code>((*</code> and <code>*))</code> are Python blocks, allowing you to use loops and conditional statements.</p> <p>The process of generating $\\LaTeX$ files like this is called \"templating,\" and it's achieved with a Python package called Jinja.</p>"},{"location":"user_guide/#creating-custom-theme-options","title":"Creating custom theme options","text":"<p>If you want to have some <code>design</code> options under your YAML input file's <code>design</code> section for your custom theme, you can create a <code>__init__.py</code> file inside your theme directory.</p> <p>For example, an <code>__init__.py</code> file is shown below:</p> <pre><code>from typing import Literal\n\nimport pydantic\n\nclass YourcustomthemeThemeOptions(pydantic.BaseModel):\n    theme: Literal[\"yourcustomtheme\"]\n    option1: str\n    option2: str\n    option3: int\n    option4: bool\n</code></pre> <p>Then, RenderCV will parse your custom design options from the YAML input, and you can use these variables inside your <code>*.j2.tex</code> files as shown below:</p> <pre><code>&lt;&lt;design.option1&gt;&gt;\n&lt;&lt;design.option2&gt;&gt;\n((* if design.option4 *))\n    &lt;&lt;design.option3&gt;&gt;\n((* endif *))\n</code></pre>"},{"location":"reference/","title":"RenderCV","text":"<p>RenderCV package.</p> <p>RenderCV is a $\\LaTeX$ CV generator from a JSON/YAML input file. The primary motivation behind the RenderCV is to allow the separation between the content and design of a CV.</p> <p>In this section, you can find how RenderCV's components are structured and how they interact with each other.</p> <ul> <li>cli.py \u2013 This module contains all the command-line interface (CLI) related code for RenderCV.</li> <li>data_models.py \u2013 This module contains classes and functions to parse and validate RenderCV's input YAML.</li> <li>renderer.py \u2013 This module implements $\\LaTeX$ file generation and $\\LaTeX$ runner utilities for RenderCV.</li> <li>themes \u2013 This package contains all the built-in themes of RenderCV.</li> </ul>"},{"location":"reference/cli/","title":"CLI","text":"<p>This module contains the functions and classes that handle the command line interface (CLI) of RenderCV. It uses Typer to create the CLI and Rich to provide a nice looking terminal output.</p>"},{"location":"reference/cli/#rendercv.cli.LiveProgressReporter","title":"<code>LiveProgressReporter(number_of_steps, end_message='Your CV is rendered!')</code>","text":"<p>             Bases: <code>Live</code></p> <p>This class is a wrapper around <code>rich.live.Live</code> that provides the live progress reporting functionality.</p> <p>Parameters:</p> <ul> <li> <code>number_of_steps</code>             (<code>int</code>)         \u2013          <p>The number of steps to be finished.</p> </li> </ul> Source code in <code>rendercv/cli.py</code> <pre><code>def __init__(self, number_of_steps: int, end_message: str = \"Your CV is rendered!\"):\n    class TimeElapsedColumn(rich.progress.ProgressColumn):\n        def render(self, task: \"rich.progress.Task\") -&gt; rich.text.Text:\n            elapsed = task.finished_time if task.finished else task.elapsed\n            delta = f\"{elapsed:.1f} s\"\n            return rich.text.Text(str(delta), style=\"progress.elapsed\")\n\n    self.step_progress = rich.progress.Progress(\n        TimeElapsedColumn(), rich.progress.TextColumn(\"{task.description}\")\n    )\n\n    self.overall_progress = rich.progress.Progress(\n        TimeElapsedColumn(),\n        rich.progress.BarColumn(),\n        rich.progress.TextColumn(\"{task.description}\"),\n    )\n\n    self.group = rich.console.Group(\n        rich.panel.Panel(rich.console.Group(self.step_progress)),\n        self.overall_progress,\n    )\n\n    self.overall_task_id = self.overall_progress.add_task(\"\", total=number_of_steps)\n    self.number_of_steps = number_of_steps\n    self.end_message = end_message\n    self.current_step = 0\n    self.overall_progress.update(\n        self.overall_task_id,\n        description=(\n            f\"[bold #AAAAAA]({self.current_step} out of\"\n            f\" {self.number_of_steps} steps finished)\"\n        ),\n    )\n    super().__init__(self.group)\n</code></pre>"},{"location":"reference/cli/#rendercv.cli.LiveProgressReporter.__enter__","title":"<code>__enter__()</code>","text":"<p>Overwrite the <code>__enter__</code> method for the correct return type.</p> Source code in <code>rendercv/cli.py</code> <pre><code>def __enter__(self) -&gt; \"LiveProgressReporter\":\n    \"\"\"Overwrite the `__enter__` method for the correct return type.\"\"\"\n    self.start(refresh=self._renderable is not None)\n    return self\n</code></pre>"},{"location":"reference/cli/#rendercv.cli.LiveProgressReporter.start_a_step","title":"<code>start_a_step(step_name)</code>","text":"<p>Start a step and update the progress bars.</p> Source code in <code>rendercv/cli.py</code> <pre><code>def start_a_step(self, step_name: str):\n    \"\"\"Start a step and update the progress bars.\"\"\"\n    self.current_step_name = step_name\n    self.current_step_id = self.step_progress.add_task(\n        f\"{self.current_step_name} has started.\"\n    )\n</code></pre>"},{"location":"reference/cli/#rendercv.cli.LiveProgressReporter.finish_the_current_step","title":"<code>finish_the_current_step()</code>","text":"<p>Finish the current step and update the progress bars.</p> Source code in <code>rendercv/cli.py</code> <pre><code>def finish_the_current_step(self):\n    \"\"\"Finish the current step and update the progress bars.\"\"\"\n    self.step_progress.stop_task(self.current_step_id)\n    self.step_progress.update(\n        self.current_step_id, description=f\"{self.current_step_name} has finished.\"\n    )\n    self.current_step += 1\n    self.overall_progress.update(\n        self.overall_task_id,\n        description=(\n            f\"[bold #AAAAAA]({self.current_step} out of\"\n            f\" {self.number_of_steps} steps finished)\"\n        ),\n        advance=1,\n    )\n    if self.current_step == self.number_of_steps:\n        self.end()\n</code></pre>"},{"location":"reference/cli/#rendercv.cli.LiveProgressReporter.end","title":"<code>end()</code>","text":"<p>End the live progress reporting.</p> Source code in <code>rendercv/cli.py</code> <pre><code>def end(self):\n    \"\"\"End the live progress reporting.\"\"\"\n    self.overall_progress.update(\n        self.overall_task_id,\n        description=f\"[bold green]{self.end_message}\",\n    )\n</code></pre>"},{"location":"reference/cli/#rendercv.cli.welcome","title":"<code>welcome()</code>","text":"<p>Print a welcome message to the terminal.</p> Source code in <code>rendercv/cli.py</code> <pre><code>def welcome():\n    \"\"\"Print a welcome message to the terminal.\"\"\"\n    table = rich.table.Table(\n        title=(\n            \"\\nWelcome to [bold]Render[dodger_blue3]CV[/dodger_blue3][/bold]! Some\"\n            \" useful links:\"\n        ),\n        title_justify=\"left\",\n    )\n\n    table.add_column(\"Title\", style=\"magenta\")\n    table.add_column(\"Link\", style=\"cyan\", justify=\"right\", no_wrap=True)\n\n    table.add_row(\"Documentation\", \"https://sinaatalay.github.io/rendercv/\")\n    table.add_row(\"Source code\", \"https://github.com/sinaatalay/rendercv/\")\n    table.add_row(\"Bug reports\", \"https://github.com/sinaatalay/rendercv/issues/\")\n    table.add_row(\"Feature requests\", \"https://github.com/sinaatalay/rendercv/issues/\")\n    table.add_row(\"Discussions\", \"https://github.com/sinaatalay/rendercv/discussions/\")\n\n    print(table)\n</code></pre>"},{"location":"reference/cli/#rendercv.cli.warning","title":"<code>warning(text)</code>","text":"<p>Print a warning message to the terminal.</p> <p>Parameters:</p> <ul> <li> <code>text</code>             (<code>str</code>)         \u2013          <p>The text of the warning message.</p> </li> </ul> Source code in <code>rendercv/cli.py</code> <pre><code>def warning(text: str):\n    \"\"\"Print a warning message to the terminal.\n\n    Args:\n        text (str): The text of the warning message.\n    \"\"\"\n    print(f\"[bold yellow]{text}\")\n</code></pre>"},{"location":"reference/cli/#rendercv.cli.error","title":"<code>error(text, exception=None)</code>","text":"<p>Print an error message to the terminal.</p> <p>Parameters:</p> <ul> <li> <code>text</code>             (<code>str</code>)         \u2013          <p>The text of the error message.</p> </li> <li> <code>exception</code>             (<code>Exception</code>, default:                 <code>None</code> )         \u2013          <p>An exception object. Defaults to None.</p> </li> </ul> Source code in <code>rendercv/cli.py</code> <pre><code>def error(text: str, exception: Optional[Exception] = None):\n    \"\"\"Print an error message to the terminal.\n\n    Args:\n        text (str): The text of the error message.\n        exception (Exception, optional): An exception object. Defaults to None.\n    \"\"\"\n    if exception is not None:\n        exception_messages = [str(arg) for arg in exception.args]\n        exception_message = \"\\n\\n\".join(exception_messages)\n        print(\n            f\"\\n[bold red]{text}[/bold red]\\n\\n[orange4]{exception_message}[/orange4]\\n\"\n        )\n    else:\n        print(f\"\\n[bold red]{text}\\n\")\n</code></pre>"},{"location":"reference/cli/#rendercv.cli.information","title":"<code>information(text)</code>","text":"<p>Print an information message to the terminal.</p> <p>Parameters:</p> <ul> <li> <code>text</code>             (<code>str</code>)         \u2013          <p>The text of the information message.</p> </li> </ul> Source code in <code>rendercv/cli.py</code> <pre><code>def information(text: str):\n    \"\"\"Print an information message to the terminal.\n\n    Args:\n        text (str): The text of the information message.\n    \"\"\"\n    print(f\"[bold green]{text}\")\n</code></pre>"},{"location":"reference/cli/#rendercv.cli.get_error_message_and_location_and_value_from_a_custom_error","title":"<code>get_error_message_and_location_and_value_from_a_custom_error(error_string)</code>","text":"<p>Look at a string and figure out if it's a custom error message that has been sent from <code>data_models.py</code>. If it is, then return the custom message, location, and the input value.</p> <p>This is done because sometimes we raise an error about a specific field in the model validation level, but Pydantic doesn't give us the exact location of the error because it's a model-level error. So, we raise a custom error with three string arguments: message, location, and input value. Those arguments then combined into a string by Python. This function is used to parse that custom error message and return the three values.</p> <p>Parameters:</p> <ul> <li> <code>error_string</code>             (<code>str</code>)         \u2013          <p>The error message.</p> </li> </ul> <p>Returns:     tuple[Optional[str], Optional[str], Optional[str]]: The custom message,         location, and the input value.</p> Source code in <code>rendercv/cli.py</code> <pre><code>def get_error_message_and_location_and_value_from_a_custom_error(\n    error_string: str,\n) -&gt; tuple[Optional[str], Optional[str], Optional[str]]:\n    \"\"\"Look at a string and figure out if it's a custom error message that has been\n    sent from [`data_models.py`](data_models.md). If it is, then return the custom\n    message, location, and the input value.\n\n    This is done because sometimes we raise an error about a specific field in the model\n    validation level, but Pydantic doesn't give us the exact location of the error\n    because it's a model-level error. So, we raise a custom error with three string\n    arguments: message, location, and input value. Those arguments then combined into a\n    string by Python. This function is used to parse that custom error message and\n    return the three values.\n\n    Args:\n        error_string (str): The error message.\n    Returns:\n        tuple[Optional[str], Optional[str], Optional[str]]: The custom message,\n            location, and the input value.\n    \"\"\"\n    pattern = r\"\"\"\\(['\"](.*)['\"], '(.*)', '(.*)'\\)\"\"\"\n    match = re.search(pattern, error_string)\n    if match:\n        return match.group(1), match.group(2), match.group(3)\n    else:\n        return None, None, None\n</code></pre>"},{"location":"reference/cli/#rendercv.cli.handle_validation_error","title":"<code>handle_validation_error(exception)</code>","text":"<p>Take a Pydantic validation error and print the error messages in a nice table.</p> <p>Pydantic's ValidationError object is a complex object that contains a lot of information about the error. This function takes a ValidationError object and extracts the error messages, locations, and the input values. Then, it prints them in a nice table with Rich.</p> <p>Parameters:</p> <ul> <li> <code>exception</code>             (<code>ValidationError</code>)         \u2013          <p>The Pydantic validation error object.</p> </li> </ul> Source code in <code>rendercv/cli.py</code> <pre><code>def handle_validation_error(exception: pydantic.ValidationError):\n    \"\"\"Take a Pydantic validation error and print the error messages in a nice table.\n\n    Pydantic's ValidationError object is a complex object that contains a lot of\n    information about the error. This function takes a ValidationError object and\n    extracts the error messages, locations, and the input values. Then, it prints them\n    in a nice table with [Rich](https://rich.readthedocs.io/en/latest/).\n\n    Args:\n        exception (pydantic.ValidationError): The Pydantic validation error object.\n    \"\"\"\n    # This dictionary is used to convert the error messages that Pydantic returns to\n    # more user-friendly messages.\n    error_dictionary: dict[str, str] = {\n        \"Input should be 'present'\": (\n            \"This is not a valid date! Please use either YYYY-MM-DD, YYYY-MM, or YYYY\"\n            ' format or \"present\"!'\n        ),\n        \"Input should be a valid integer, unable to parse string as an integer\": (\n            \"This is not a valid date! Please use either YYYY-MM-DD, YYYY-MM, or YYYY\"\n            \" format!\"\n        ),\n        \"String should match pattern '\\\\d{4}-\\\\d{2}(-\\\\d{2})?'\": (\n            \"This is not a valid date! Please use either YYYY-MM-DD, YYYY-MM, or YYYY\"\n            \" format!\"\n        ),\n        \"URL scheme should be 'http' or 'https'\": \"This is not a valid URL!\",\n        \"Field required\": \"This field is required!\",\n        \"value is not a valid phone number\": \"This is not a valid phone number!\",\n        \"month must be in 1..12\": \"The month must be between 1 and 12!\",\n        \"Value error, day is out of range for month\": (\n            \"The day is out of range for the month!\"\n        ),\n        \"Extra inputs are not permitted\": (\n            \"This field is unknown for this object! Please remove it.\"\n        ),\n        \"Input should be a valid string\": \"This field should be a string!\",\n        \"Input should be a valid list\": (\n            \"This field should contain a list of items but it doesn't!\"\n        ),\n    }\n\n    # Check if this is a section error. If it is, we need to handle it differently.\n    # This is needed because how dm.validate_section_input function raises an exception.\n    # This is done to tell the user which which EntryType RenderCV excepts to see.\n    errors = exception.errors()\n    for error_object in errors.copy():\n        if (\n            \"There are problems with the entries.\" in error_object[\"msg\"]\n            and \"ctx\" in error_object\n        ):\n            location = error_object[\"loc\"]\n            ctx_object = error_object[\"ctx\"]\n            if \"error\" in ctx_object:\n                error_object = ctx_object[\"error\"]\n                if hasattr(error_object, \"__cause__\"):\n                    cause_object = error_object.__cause__\n                    cause_object_errors = cause_object.errors()\n                    for cause_error_object in cause_object_errors:\n                        # we use [1:] to avoid `entries` location. It is a location for\n                        # RenderCV's own data model, not the user's data model.\n                        cause_error_object[\"loc\"] = tuple(\n                            list(location) + list(cause_error_object[\"loc\"][1:])\n                        )\n                    errors.extend(cause_object_errors)\n\n    # some locations are not really the locations in the input file, but some\n    # information about the model coming from Pydantic. We need to remove them.\n    # (e.g. avoid stuff like .end_date.literal['present'])\n    unwanted_locations = [\"tagged-union\", \"list\", \"literal\"]\n    for error_object in errors:\n        location = error_object[\"loc\"]\n        new_location = [str(location_element) for location_element in location]\n        for location_element in location:\n            location_element = str(location_element)\n            for unwanted_location in unwanted_locations:\n                if unwanted_location in location_element:\n                    new_location.remove(location_element)\n        error_object[\"loc\"] = new_location  # type: ignore\n\n    # Parse all the errors and create a new list of errors.\n    new_errors: list[dict[str, str]] = []\n    end_date_error_is_found = False\n    for error_object in errors:\n        message = error_object[\"msg\"]\n        location = \".\".join(error_object[\"loc\"])  # type: ignore\n        input = error_object[\"input\"]\n\n        # Check if this is a custom error message:\n        custom_message, custom_location, custom_input_value = (\n            get_error_message_and_location_and_value_from_a_custom_error(message)\n        )\n        if custom_message is not None:\n            message = custom_message\n            if custom_location != \"\":\n                # If the custom location is not empty, then add it to the location.\n                location = f\"{location}.{custom_location}\"\n            input = custom_input_value\n\n        # Convert the error message to a more user-friendly message if it's in the\n        # error_dictionary:\n        if message in error_dictionary:\n            message = error_dictionary[message]\n\n        # Don't show \"Value error, \", since the message is already clear.\n        message = message.replace(\"Value error, \", \"\")\n\n        # Special case for end_date because Pydantic returns multiple end_date errors\n        # since it has multiple valid formats:\n        if \"end_date.\" in location:\n            if end_date_error_is_found:\n                continue\n            end_date_error_is_found = True\n            message = (\n                \"This is not a valid end date! Please use either YYYY-MM-DD, YYYY-MM,\"\n                ' or YYYY format or \"present\"!'\n            )\n\n        # If the input is a dictionary or a list (the model itself fails to validate),\n        # then don't show the input. It looks confusing and it is not helpful.\n        if isinstance(input, (dict, list)):\n            input = \"\"\n\n        new_errors.append(\n            {\n                \"loc\": str(location),\n                \"msg\": message,\n                \"input\": str(input),\n            }\n        )\n\n    # Print the errors in a nice table:\n    table = rich.table.Table(\n        title=\"[bold red]\\nThere are some errors in the input file!\\n\",\n        title_justify=\"left\",\n        show_lines=True,\n    )\n    table.add_column(\"Location\", style=\"cyan\", no_wrap=True)\n    table.add_column(\"Input Value\", style=\"magenta\")\n    table.add_column(\"Error Message\", style=\"orange4\")\n\n    for error_object in new_errors:\n        table.add_row(\n            error_object[\"loc\"],\n            error_object[\"input\"],\n            error_object[\"msg\"],\n        )\n\n    print(table)\n    print()  # Add an empty line at the end to make it look better.\n</code></pre>"},{"location":"reference/cli/#rendercv.cli.handle_exceptions","title":"<code>handle_exceptions(function)</code>","text":"<p>Return a wrapper function that handles exceptions.</p> <p>A decorator in Python is a syntactic convenience that allows a Python to interpret the code below:</p> <p><pre><code>@handle_exceptions\ndef my_function():\n    pass\n</code></pre> as <pre><code>handle_exceptions(my_function)()\n</code></pre> which is step by step equivalent to</p> <ol> <li>Execute <code>handle_exceptions(my_function)</code> which will return the     function called <code>wrapper</code>.</li> <li>Execute <code>wrapper()</code>.</li> </ol> <p>Parameters:</p> <ul> <li> <code>function</code>             (<code>Callable</code>)         \u2013          <p>The function to be wrapped.</p> </li> </ul> <p>Returns:     Callable: The wrapped function.</p> Source code in <code>rendercv/cli.py</code> <pre><code>def handle_exceptions(function: Callable) -&gt; Callable:\n    \"\"\"Return a wrapper function that handles exceptions.\n\n    A decorator in Python is a syntactic convenience that allows a Python to interpret\n    the code below:\n\n    ```python\n    @handle_exceptions\n    def my_function():\n        pass\n    ```\n    as\n    ```python\n    handle_exceptions(my_function)()\n    ```\n    which is step by step equivalent to\n\n    1.  Execute `#!python handle_exceptions(my_function)` which will return the\n        function called `wrapper`.\n    2.  Execute `#!python wrapper()`.\n\n    Args:\n        function (Callable): The function to be wrapped.\n    Returns:\n        Callable: The wrapped function.\n    \"\"\"\n\n    @functools.wraps(function)\n    def wrapper(*args, **kwargs):\n        try:\n            function(*args, **kwargs)\n        except pydantic.ValidationError as e:\n            handle_validation_error(e)\n        except ruamel.yaml.YAMLError as e:\n            error(\"There is a YAML error in the input file!\", e)\n        except FileNotFoundError as e:\n            error(e)\n        except UnicodeDecodeError as e:\n            # find the problematic character that cannot be decoded with utf-8\n            bad_character = str(e.object[e.start : e.end])\n            try:\n                bad_character_context = str(e.object[e.start - 16 : e.end + 16])\n            except IndexError:\n                bad_character_context = \"\"\n\n            error(\n                \"The input file contains a character that cannot be decoded with\"\n                f\" UTF-8 ({bad_character}):\\n {bad_character_context}\",\n            )\n\n        except ValueError as e:\n            error(e)\n        except RuntimeError as e:\n            error(\"An error occurred:\", e)\n\n    return wrapper\n</code></pre>"},{"location":"reference/cli/#rendercv.cli.cli_command_render","title":"<code>cli_command_render(input_file_name, local_latex_command=None)</code>","text":"<p>Generate a $\\LaTeX$ CV from a YAML input file.</p> <p>Parameters:</p> <ul> <li> <code>input_file_path</code>             (<code>str</code>)         \u2013          <p>Path to the YAML input file as a string.</p> </li> <li> <code>use_local_latex</code>             (<code>bool</code>)         \u2013          <p>Use the local LaTeX installation instead of the RenderCV's TinyTeX. The default is False.</p> </li> </ul> Source code in <code>rendercv/cli.py</code> <pre><code>@app.command(\n    name=\"render\",\n    help=(\n        \"Render a YAML input file. Example: [bold green]rendercv render\"\n        \" John_Doe_CV.yaml[/bold green]\"\n    ),\n)\n@handle_exceptions\ndef cli_command_render(\n    input_file_name: Annotated[\n        str,\n        typer.Argument(help=\"Name of the YAML input file.\"),\n    ],\n    local_latex_command: Annotated[\n        Optional[str],\n        typer.Option(\n            \"--use-local-latex-command\",\n            help=(\n                \"Use the local LaTeX installation with the given command instead of the\"\n                \" RenderCV's TinyTeX.\"\n            ),\n        ),\n    ] = None,\n):\n    \"\"\"Generate a $\\\\LaTeX$ CV from a YAML input file.\n\n    Args:\n        input_file_path (str): Path to the YAML input file as a string.\n        use_local_latex (bool, optional): Use the local LaTeX installation instead of\n            the RenderCV's TinyTeX. The default is False.\n    \"\"\"\n    welcome()\n\n    input_file_path = pathlib.Path(input_file_name)\n\n    output_directory = input_file_path.parent / \"rendercv_output\"\n\n    with LiveProgressReporter(number_of_steps=5) as progress:\n        progress.start_a_step(\"Reading and validating the input file\")\n        data_model = dm.read_input_file(input_file_path)\n        progress.finish_the_current_step()\n\n        progress.start_a_step(\"Generating the LaTeX file\")\n        latex_file_path = r.generate_latex_file_and_copy_theme_files(\n            data_model, output_directory\n        )\n        progress.finish_the_current_step()\n\n        progress.start_a_step(\"Generating the Markdown file\")\n        markdown_file_path = r.generate_markdown_file(data_model, output_directory)\n        progress.finish_the_current_step()\n\n        progress.start_a_step(\"Rendering the LaTeX file to a PDF\")\n        r.latex_to_pdf(latex_file_path, local_latex_command)\n        progress.finish_the_current_step()\n\n        progress.start_a_step(\"Rendering the Markdown file to a HTML (for Grammarly)\")\n        r.markdown_to_html(markdown_file_path)\n        progress.finish_the_current_step()\n</code></pre>"},{"location":"reference/cli/#rendercv.cli.cli_command_new","title":"<code>cli_command_new(full_name, theme='classic')</code>","text":"<p>Generate a YAML input file to get started.</p> Source code in <code>rendercv/cli.py</code> <pre><code>@app.command(\n    name=\"new\",\n    help=(\n        \"Generate a YAML input file to get started. Example: [bold green]rendercv new\"\n        ' \"John Doe\"[/bold green]'\n    ),\n)\ndef cli_command_new(\n    full_name: Annotated[str, typer.Argument(help=\"Your full name.\")],\n    theme: Annotated[str, typer.Option(help=\"The theme of the CV.\")] = \"classic\",\n):\n    \"\"\"Generate a YAML input file to get started.\"\"\"\n    data_model = dm.get_a_sample_data_model(full_name, theme)\n    file_name = f\"{full_name.replace(' ', '_')}_CV.yaml\"\n    file_path = pathlib.Path(file_name)\n\n    # Instead of getting the dictionary with data_model.model_dump() directly, we\n    # convert it to JSON and then to a dictionary. Because the YAML library we are using\n    # sometimes has problems with the dictionary returned by model_dump().\n    data_model_as_json = data_model.model_dump_json(\n        exclude_none=True, by_alias=True, exclude={\"cv\": {\"sections\"}}\n    )\n    data_model_as_dictionary = json.loads(data_model_as_json)\n\n    yaml_object = ruamel.yaml.YAML()\n    yaml_object.encoding = \"utf-8\"\n    yaml_object.indent(mapping=2, sequence=4, offset=2)\n    yaml_object.dump(data_model_as_dictionary, file_path)\n\n    information(f\"Your RenderCV input file has been created: {file_path}!\")\n</code></pre>"},{"location":"reference/data_models/","title":"Data Models","text":"<p>This module contains all the necessary classes to store CV data. These classes are called data models. The YAML input file is transformed into instances of these classes (i.e., the input file is read) with the <code>read_input_file</code> function. RenderCV utilizes these instances to generate a $\\LaTeX$ file which is then rendered into a PDF file.</p> <p>The data models are initialized with data validation to prevent unexpected bugs. During the initialization, we ensure that everything is in the correct place and that the user has provided a valid RenderCV input. This is achieved through the use of Pydantic. Each class method decorated with 'pydantic.model_validator<code>or 'pydantic.field_validator</code> is executed automatically during the data classes' initialization.</p>"},{"location":"reference/data_models/#rendercv.data_models.RenderCVBaseModel","title":"<code>RenderCVBaseModel</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>This class is the parent class of all the data models in RenderCV. It has only one difference from the default <code>pydantic.BaseModel</code>: It raises an error if an unknown key is provided in the input file.</p>"},{"location":"reference/data_models/#rendercv.data_models.OneLineEntry","title":"<code>OneLineEntry</code>","text":"<p>             Bases: <code>RenderCVBaseModel</code></p> <p>This class is the data model of <code>OneLineEntry</code>.</p>"},{"location":"reference/data_models/#rendercv.data_models.PublicationEntry","title":"<code>PublicationEntry</code>","text":"<p>             Bases: <code>RenderCVBaseModel</code></p> <p>This class is the data model of <code>PublicationEntry</code>.</p>"},{"location":"reference/data_models/#rendercv.data_models.PublicationEntry.doi_url","title":"<code>doi_url: str</code>  <code>cached</code> <code>property</code>","text":"<p>Return the URL of the DOI.</p>"},{"location":"reference/data_models/#rendercv.data_models.PublicationEntry.date_string","title":"<code>date_string: str</code>  <code>cached</code> <code>property</code>","text":"<p>Return the date string of the publication.</p>"},{"location":"reference/data_models/#rendercv.data_models.PublicationEntry.check_date","title":"<code>check_date(date)</code>  <code>classmethod</code>","text":"<p>Check if the date is a valid date.</p> Source code in <code>rendercv/data_models.py</code> <pre><code>@pydantic.field_validator(\"date\")\n@classmethod\ndef check_date(cls, date: int | RenderCVDate) -&gt; int | RenderCVDate:\n    \"\"\"Check if the date is a valid date.\"\"\"\n    # The function below will raise an error if the date is not valid:\n    get_date_object(date)\n\n    return date\n</code></pre>"},{"location":"reference/data_models/#rendercv.data_models.PublicationEntry.check_doi","title":"<code>check_doi(doi)</code>  <code>classmethod</code>","text":"<p>Check if the DOI exists in the DOI System.</p> Source code in <code>rendercv/data_models.py</code> <pre><code>@pydantic.field_validator(\"doi\")\n@classmethod\ndef check_doi(cls, doi: Optional[str]) -&gt; Optional[str]:\n    \"\"\"Check if the DOI exists in the DOI System.\"\"\"\n    if doi is not None:\n        # see https://stackoverflow.com/a/60671292/18840665 for the explanation of\n        # the next line:\n        ssl._create_default_https_context = ssl._create_unverified_context  # type: ignore\n\n        doi_url = f\"http://doi.org/{doi}\"\n\n        try:\n            urlopen(doi_url)\n        except HTTPError as err:\n            if err.code == 404:\n                raise ValueError(\"DOI cannot be found in the DOI System!\")\n        except InvalidURL:\n            raise ValueError(\"This DOI is not valid!\")\n\n    return doi\n</code></pre>"},{"location":"reference/data_models/#rendercv.data_models.BulletEntry","title":"<code>BulletEntry</code>","text":"<p>             Bases: <code>RenderCVBaseModel</code></p> <p>This class is the data model of <code>BulletEntry</code>.</p>"},{"location":"reference/data_models/#rendercv.data_models.EntryBase","title":"<code>EntryBase</code>","text":"<p>             Bases: <code>RenderCVBaseModel</code></p> <p>This class is the parent class of some of the entry types. It is being used because some of the entry types have common fields like dates, highlights, location, etc.</p>"},{"location":"reference/data_models/#rendercv.data_models.EntryBase.date_string","title":"<code>date_string: str</code>  <code>cached</code> <code>property</code>","text":"<p>Return a date string based on the <code>date</code>, <code>start_date</code>, and <code>end_date</code> fields.</p> Example <p><pre><code>entry = dm.EntryBase(start_date=2020-10-11, end_date=2021-04-04).date_string\n</code></pre> will return: <code>\"2020-10-11 to 2021-04-04\"</code></p>"},{"location":"reference/data_models/#rendercv.data_models.EntryBase.date_string_only_years","title":"<code>date_string_only_years: str</code>  <code>cached</code> <code>property</code>","text":"<p>Return a date string that only contains years based on the <code>date</code>, <code>start_date</code>, and <code>end_date</code> fields.</p> Example <p><pre><code>entry = dm.EntryBase(start_date=2020-10-11, end_date=2021-04-04).date_string\n</code></pre> will return: <code>\"2020 to 2021\"</code></p>"},{"location":"reference/data_models/#rendercv.data_models.EntryBase.time_span_string","title":"<code>time_span_string: str</code>  <code>cached</code> <code>property</code>","text":"<p>Return a time span string based on the <code>date</code>, <code>start_date</code>, and <code>end_date</code> fields.</p> Example <p><pre><code>entry = dm.EntryBase(start_date=2020-01-01, end_date=2020-04-20).time_span\n</code></pre> will return: <code>\"4 months\"</code></p>"},{"location":"reference/data_models/#rendercv.data_models.EntryBase.check_and_adjust_dates","title":"<code>check_and_adjust_dates()</code>","text":"<p>Check if the dates are provided correctly and do the necessary adjustments.</p> Source code in <code>rendercv/data_models.py</code> <pre><code>@pydantic.model_validator(\n    mode=\"after\",\n)\ndef check_and_adjust_dates(self) -&gt; \"EntryBase\":\n    \"\"\"\n    Check if the dates are provided correctly and do the necessary adjustments.\n    \"\"\"\n    date_is_provided = self.date is not None\n    start_date_is_provided = self.start_date is not None\n    end_date_is_provided = self.end_date is not None\n\n    if date_is_provided:\n        # If only date is provided, ignore start_date and end_date:\n        self.start_date = None\n        self.end_date = None\n\n    elif not start_date_is_provided and end_date_is_provided:\n        # If only end_date is provided, assume it is a one-day event and act like\n        # only the date is provided:\n        self.date = self.end_date\n        self.start_date = None\n        self.end_date = None\n    elif start_date_is_provided:\n        start_date = get_date_object(self.start_date)\n        if not end_date_is_provided:\n            # Then it means only the start_date is provided, so it is an ongoing\n            # event:\n            self.end_date = \"present\"\n            end_date = Date.today()\n        else:\n            end_date = get_date_object(self.end_date)\n\n        if start_date &gt; end_date:\n            raise ValueError(\n                '\"start_date\" can not be after \"end_date\"!',\n                \"start_date\",  # this is the location of the error\n                str(start_date),  # this is value of the error\n            )\n\n    return self\n</code></pre>"},{"location":"reference/data_models/#rendercv.data_models.NormalEntry","title":"<code>NormalEntry</code>","text":"<p>             Bases: <code>EntryBase</code>, <code>NormalEntryBase</code></p> <p>This class is the data model of <code>NormalEntry</code>.</p>"},{"location":"reference/data_models/#rendercv.data_models.ExperienceEntry","title":"<code>ExperienceEntry</code>","text":"<p>             Bases: <code>EntryBase</code>, <code>ExperienceEntryBase</code></p> <p>This class is the data model of <code>ExperienceEntry</code>.</p>"},{"location":"reference/data_models/#rendercv.data_models.EducationEntry","title":"<code>EducationEntry</code>","text":"<p>             Bases: <code>EntryBase</code>, <code>EducationEntryBase</code></p> <p>This class is the data model of <code>EducationEntry</code>.</p>"},{"location":"reference/data_models/#rendercv.data_models.SectionBase","title":"<code>SectionBase</code>","text":"<p>             Bases: <code>RenderCVBaseModel</code></p> <p>This class is the parent class of all the section types. It is being used because all of the section types have a common field called <code>title</code>.</p>"},{"location":"reference/data_models/#rendercv.data_models.SocialNetwork","title":"<code>SocialNetwork</code>","text":"<p>             Bases: <code>RenderCVBaseModel</code></p> <p>This class is the data model of a social network.</p>"},{"location":"reference/data_models/#rendercv.data_models.SocialNetwork.url","title":"<code>url: str</code>  <code>cached</code> <code>property</code>","text":"<p>Return the URL of the social network.</p>"},{"location":"reference/data_models/#rendercv.data_models.SocialNetwork.check_username","title":"<code>check_username(username, info)</code>  <code>classmethod</code>","text":"<p>Check if the username is provided correctly.</p> Source code in <code>rendercv/data_models.py</code> <pre><code>@pydantic.field_validator(\"username\")\n@classmethod\ndef check_username(cls, username: str, info: pydantic.ValidationInfo) -&gt; str:\n    \"\"\"Check if the username is provided correctly.\"\"\"\n    network = info.data[\"network\"]\n\n    if network == \"Mastodon\":\n        if not username.startswith(\"@\"):\n            raise ValueError(\"Mastodon username should start with '@'!\")\n        if username.count(\"@\") &gt; 2:\n            raise ValueError(\"Mastodon username should contain only two '@'!\")\n\n    return username\n</code></pre>"},{"location":"reference/data_models/#rendercv.data_models.SocialNetwork.validate_urls","title":"<code>validate_urls()</code>","text":"<p>Validate the URLs of the social networks.</p> Source code in <code>rendercv/data_models.py</code> <pre><code>@pydantic.model_validator(mode=\"after\")  # type: ignore\ndef validate_urls(self) -&gt; \"SocialNetwork\":\n    \"\"\"Validate the URLs of the social networks.\"\"\"\n    url = self.url\n\n    url_validator.validate_strings(url)\n\n    return self\n</code></pre>"},{"location":"reference/data_models/#rendercv.data_models.CurriculumVitae","title":"<code>CurriculumVitae</code>","text":"<p>             Bases: <code>RenderCVBaseModel</code></p> <p>This class is the data model of the CV.</p>"},{"location":"reference/data_models/#rendercv.data_models.CurriculumVitae.sections","title":"<code>sections: list[SectionBase]</code>  <code>cached</code> <code>property</code>","text":"<p>Return all the sections of the CV with their titles.</p>"},{"location":"reference/data_models/#rendercv.data_models.RenderCVDataModel","title":"<code>RenderCVDataModel</code>","text":"<p>             Bases: <code>RenderCVBaseModel</code></p> <p>This class binds both the CV and the design information together.</p>"},{"location":"reference/data_models/#rendercv.data_models.RenderCVDataModel.initialize_if_custom_theme_is_used","title":"<code>initialize_if_custom_theme_is_used(design)</code>  <code>classmethod</code>","text":"<p>Initialize the custom theme if it is used and validate it. Otherwise, return the built-in theme.</p> Source code in <code>rendercv/data_models.py</code> <pre><code>@pydantic.field_validator(\"design\", mode=\"before\")\n@classmethod\ndef initialize_if_custom_theme_is_used(\n    cls, design: RenderCVDesign | Any\n) -&gt; RenderCVDesign | Any:\n    \"\"\"Initialize the custom theme if it is used and validate it. Otherwise, return\n    the built-in theme.\"\"\"\n    # `get_args` for an Annotated object returns the arguments when Annotated is\n    # used. The first argument is actually the union of the types, so we need to\n    # access the first argument to use isinstance function.\n    theme_data_model_types = get_args(RenderCVDesign)[0]\n\n    if isinstance(design, theme_data_model_types):\n        # then it means RenderCVDataModel is already initialized with a design, so\n        # return it as is:\n        return design\n    elif design[\"theme\"] in available_themes:  # type: ignore\n        # then it means it's a built-in theme, but it is not initialized (validated)\n        # yet. So, validate and return it:\n        return rendercv_design_validator.validate_python(design)\n    else:\n        theme_name: str = design[\"theme\"]  # type: ignore\n        if not isinstance(theme_name, str):\n            raise RuntimeError(\n                \"This error shouldn't have been raised. Please open an issue on\"\n                \" GitHub.\"\n            )\n\n        # check if the theme name is valid:\n        if not theme_name.isalpha():\n            raise ValueError(\n                \"The custom theme name should contain only letters.\",\n                \"theme\",  # this is the location of the error\n                theme_name,  # this is value of the error\n            )\n\n        # then it is a custom theme\n        custom_theme_folder = pathlib.Path(theme_name)\n\n        # check if the custom theme folder exists:\n        if not custom_theme_folder.exists():\n            raise ValueError(\n                f\"The custom theme folder `{custom_theme_folder}` does not exist.\"\n                \" It should be in the working directory as the input file.\",\n                \"\",  # this is the location of the error\n                theme_name,  # this is value of the error\n            )\n\n        # check if all the necessary files are provided in the custom theme folder:\n        required_entry_files = [\n            entry_type_name + \".j2.tex\" for entry_type_name in entry_type_names\n        ]\n        required_files = [\n            \"SectionBeginning.j2.tex\",  # section beginning template\n            \"SectionEnding.j2.tex\",  # section ending template\n            \"Preamble.j2.tex\",  # preamble template\n            \"Header.j2.tex\",  # header template\n        ] + required_entry_files\n\n        for file in required_files:\n            file_path = custom_theme_folder / file\n            if not file_path.exists():\n                raise ValueError(\n                    f\"You provided a custom theme, but the file `{file}` is not\"\n                    f\" found in the folder `{custom_theme_folder}`.\",\n                    \"\",  # this is the location of the error\n                    theme_name,  # this is value of the error\n                )\n\n        # import __init__.py file from the custom theme folder if it exists:\n        path_to_init_file = pathlib.Path(f\"{theme_name}/__init__.py\")\n\n        if path_to_init_file.exists():\n            spec = importlib.util.spec_from_file_location(\n                \"theme\",\n                path_to_init_file,\n            )\n            if spec is None:\n                raise RuntimeError(\n                    \"This error shouldn't have been raised. Please open an issue on\"\n                    \" GitHub.\"\n                )\n\n            theme_module = importlib.util.module_from_spec(spec)\n            try:\n                spec.loader.exec_module(theme_module)  # type: ignore\n            except SyntaxError or ImportError:\n                raise ValueError(\n                    f\"The custom theme {theme_name}'s __init__.py file is not\"\n                    \" valid. Please check the file and try again.\",\n                )\n\n            ThemeDataModel = getattr(\n                theme_module, f\"{theme_name.title()}ThemeOptions\"  # type: ignore\n            )\n\n            # initialize and validate the custom theme data model:\n            theme_data_model = ThemeDataModel(**design)\n        else:\n            # Then it means there is no __init__.py file in the custom theme folder.\n            # So, create a dummy data model and use that instead.\n            class ThemeOptionsAreNotProvided(RenderCVBaseModel):\n                theme: str = theme_name\n\n            theme_data_model = ThemeOptionsAreNotProvided(theme=theme_name)\n\n        return theme_data_model\n</code></pre>"},{"location":"reference/data_models/#rendercv.data_models.get_date_object","title":"<code>get_date_object(date)</code>","text":"<p>Parse a date string in YYYY-MM-DD, YYYY-MM, or YYYY format and return a datetime.date object. This function is used throughout the validation process of the data models.</p> <p>Parameters:</p> <ul> <li> <code>date</code>             (<code>str</code>)         \u2013          <p>The date string to parse.</p> </li> </ul> <p>Returns:     datetime.date: The parsed date.</p> Source code in <code>rendercv/data_models.py</code> <pre><code>def get_date_object(date: str | int) -&gt; Date:\n    \"\"\"Parse a date string in YYYY-MM-DD, YYYY-MM, or YYYY format and return a\n    datetime.date object. This function is used throughout the validation process of the\n    data models.\n\n    Args:\n        date (str): The date string to parse.\n    Returns:\n        datetime.date: The parsed date.\n    \"\"\"\n    if isinstance(date, int):\n        date_object = Date.fromisoformat(f\"{date}-01-01\")\n    elif re.fullmatch(r\"\\d{4}-\\d{2}-\\d{2}\", date):\n        # Then it is in YYYY-MM-DD format\n        date_object = Date.fromisoformat(date)\n    elif re.fullmatch(r\"\\d{4}-\\d{2}\", date):\n        # Then it is in YYYY-MM format\n        date_object = Date.fromisoformat(f\"{date}-01\")\n    elif re.fullmatch(r\"\\d{4}\", date):\n        # Then it is in YYYY format\n        date_object = Date.fromisoformat(f\"{date}-01-01\")\n    elif date == \"present\":\n        date_object = Date.today()\n    else:\n        raise ValueError(\n            \"This is not a valid date! Please use either YYYY-MM-DD, YYYY-MM, or\"\n            \" YYYY format.\"\n        )\n\n    return date_object\n</code></pre>"},{"location":"reference/data_models/#rendercv.data_models.format_date","title":"<code>format_date(date)</code>","text":"<p>Formats a <code>Date</code> object to a string in the following format: \"Jan. 2021\".</p> <p>It uses month abbreviations, taken from Yale University Library.</p> Example <p><pre><code>format_date(Date(2024, 5, 1))\n</code></pre> will return</p> <p><code>\"May 2024\"</code></p> <p>Parameters:</p> <ul> <li> <code>date</code>             (<code>date</code>)         \u2013          <p>The date to format.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code> (            <code>str</code> )        \u2013          <p>The formatted date.</p> </li> </ul> Source code in <code>rendercv/data_models.py</code> <pre><code>def format_date(date: Date) -&gt; str:\n    \"\"\"Formats a `Date` object to a string in the following format: \"Jan. 2021\".\n\n    It uses month abbreviations, taken from\n    [Yale University Library](https://web.library.yale.edu/cataloging/months).\n\n    Example:\n        ```python\n        format_date(Date(2024, 5, 1))\n        ```\n        will return\n\n        `#!python \"May 2024\"`\n\n    Args:\n        date (Date): The date to format.\n\n    Returns:\n        str: The formatted date.\n    \"\"\"\n    # Month abbreviations,\n    # taken from: https://web.library.yale.edu/cataloging/months\n    abbreviations_of_months = [\n        \"Jan.\",\n        \"Feb.\",\n        \"Mar.\",\n        \"Apr.\",\n        \"May\",\n        \"June\",\n        \"July\",\n        \"Aug.\",\n        \"Sept.\",\n        \"Oct.\",\n        \"Nov.\",\n        \"Dec.\",\n    ]\n\n    month = int(date.strftime(\"%m\"))\n    month_abbreviation = abbreviations_of_months[month - 1]\n    year = date.strftime(format=\"%Y\")\n    date_string = f\"{month_abbreviation} {year}\"\n\n    return date_string\n</code></pre>"},{"location":"reference/data_models/#rendercv.data_models.create_a_section_model","title":"<code>create_a_section_model(entry_type)</code>","text":"<p>Create a section model based on the entry type. See Pydantic's documentation about dynamic model creation for more information.</p> <p>Parameters:</p> <ul> <li> <code>entry_type</code>             (<code>Type[Entry]</code>)         \u2013          <p>The entry type to create the section model.</p> </li> </ul> <p>Returns:     Type[SectionBase]: The section model.</p> Source code in <code>rendercv/data_models.py</code> <pre><code>def create_a_section_model(entry_type: Type[Entry]) -&gt; Type[SectionBase]:\n    \"\"\"Create a section model based on the entry type. See [Pydantic's documentation\n    about dynamic model\n    creation](https://pydantic-docs.helpmanual.io/usage/models/#dynamic-model-creation)\n    for more information.\n\n    Args:\n        entry_type (Type[Entry]): The entry type to create the section model.\n    Returns:\n        Type[SectionBase]: The section model.\n    \"\"\"\n    if entry_type == str:\n        model_name = \"SectionWithTextEntries\"\n        entry_type_name = \"TextEntry\"\n    else:\n        model_name = \"SectionWith\" + entry_type.__name__.replace(\"Entry\", \"Entries\")\n        entry_type_name = entry_type.__name__\n\n    SectionModel = pydantic.create_model(\n        model_name,\n        entry_type=(Literal[entry_type_name], ...),  # type: ignore\n        entries=(list[entry_type], ...),\n        __base__=SectionBase,\n    )\n\n    return SectionModel\n</code></pre>"},{"location":"reference/data_models/#rendercv.data_models.get_entry_and_section_type","title":"<code>get_entry_and_section_type(entry)</code>","text":"<p>Determine the entry and section type based on the entry.</p> <p>Parameters:</p> <ul> <li> <code>entry</code>             (<code>dict[str, Any] | Entry</code>)         \u2013          <p>The entry to determine the type.</p> </li> </ul> <p>Returns:     tuple[str, Type[Section]]: The entry type and the section type.</p> Source code in <code>rendercv/data_models.py</code> <pre><code>def get_entry_and_section_type(\n    entry: dict[str, Any] | Entry,\n) -&gt; tuple[\n    str,\n    Type[SectionBase],\n]:\n    \"\"\"Determine the entry and section type based on the entry.\n\n    Args:\n        entry: The entry to determine the type.\n    Returns:\n        tuple[str, Type[Section]]: The entry type and the section type.\n    \"\"\"\n    # Get class attributes of EntryBase class:\n    common_attributes = set(EntryBase.model_fields.keys())\n\n    if isinstance(entry, dict):\n        entry_type = None  # the entry type is not determined yet\n\n        for EntryType in entry_types:\n            characteristic_entry_attributes = (\n                set(EntryType.model_fields.keys()) - common_attributes\n            )\n\n            # If at least one of the characteristic_entry_attributes is in the entry,\n            # then it means the entry is of this type:\n            if characteristic_entry_attributes &amp; set(entry.keys()):\n                entry_type = EntryType.__name__\n                section_type = create_a_section_model(EntryType)\n                break\n\n        if entry_type is None:\n            raise ValueError(\"The entry is not provided correctly.\")\n\n    elif isinstance(entry, str):\n        # Then it is a TextEntry\n        entry_type = \"TextEntry\"\n        section_type = create_a_section_model(str)\n\n    else:\n        # Then the entry is already initialized with a data model:\n        entry_type = entry.__class__.__name__\n        section_type = create_a_section_model(entry.__class__)\n\n    return entry_type, section_type\n</code></pre>"},{"location":"reference/data_models/#rendercv.data_models.validate_section_input","title":"<code>validate_section_input(sections_input)</code>","text":"<p>Validate a SectionInput object and raise an error if it is not valid.</p> <p>Sections input is very complex. It is either a <code>Section</code> object or a list of entries. Since there are multiple entry types, it is not possible to validate it directly. This function looks at the entry list's first element and determines the section's entry type based on the first element. Then, it validates the rest of the list based on the determined entry type. If it is a <code>Section</code> object, then it validates it directly.</p> <p>Parameters:</p> <ul> <li> <code>sections_input</code>             (<code>Section | list[Any]</code>)         \u2013          <p>The sections input to validate.</p> </li> </ul> <p>Returns:     Section | list[Any]: The validated sections input.</p> Source code in <code>rendercv/data_models.py</code> <pre><code>def validate_section_input(\n    sections_input: SectionBase | list[Any],\n) -&gt; SectionBase | list[Any]:\n    \"\"\"Validate a SectionInput object and raise an error if it is not valid.\n\n    Sections input is very complex. It is either a `Section` object or a list of\n    entries. Since there are multiple entry types, it is not possible to validate it\n    directly. This function looks at the entry list's first element and determines the\n    section's entry type based on the first element. Then, it validates the rest of the\n    list based on the determined entry type. If it is a `Section` object, then it\n    validates it directly.\n\n    Args:\n        sections_input (Section | list[Any]): The sections input to validate.\n    Returns:\n        Section | list[Any]: The validated sections input.\n    \"\"\"\n    if isinstance(sections_input, list):\n        # find the entry type based on the first identifiable entry:\n        entry_type = None\n        section_type = None\n        for entry in sections_input:\n            try:\n                entry_type, section_type = get_entry_and_section_type(entry)\n                break\n            except ValueError:\n                pass\n\n        if entry_type is None or section_type is None:\n            raise ValueError(\n                \"RenderCV couldn't match this section with any entry type! Please check\"\n                \" the entries and make sure they are provided correctly.\",\n                \"\",  # this is the location of the error\n                \"\",  # this is value of the error\n            )\n\n        test_section = {\n            \"title\": \"Test Section\",\n            \"entry_type\": entry_type,\n            \"entries\": sections_input,\n        }\n\n        try:\n            section_type.model_validate(\n                test_section,\n                context={\"section\": \"test\"},\n            )\n        except pydantic.ValidationError as e:\n            new_error = ValueError(\n                \"There are problems with the entries. RenderCV detected the entry type\"\n                f\" of this section to be {entry_type}! The problems are shown below.\",\n                \"\",  # this is the location of the error\n                \"\",  # this is value of the error\n            )\n            raise new_error from e\n\n    return sections_input\n</code></pre>"},{"location":"reference/data_models/#rendercv.data_models.read_input_file","title":"<code>read_input_file(file_path)</code>","text":"<p>Read the input file and return two instances of RenderCVDataModel. The first instance is the data model with $\\LaTeX$ strings and the second instance is the data model with markdown strings.</p> <p>Parameters:</p> <ul> <li> <code>file_path</code>             (<code>str</code>)         \u2013          <p>The path to the input file.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RenderCVDataModel</code>         \u2013          <p>tuple[RenderCVDataModel, RenderCVDataModel]: The data models with $\\LaTeX$ and</p> </li> <li> <code>RenderCVDataModel</code>         \u2013          <p>markdown strings.</p> </li> </ul> Source code in <code>rendercv/data_models.py</code> <pre><code>def read_input_file(\n    file_path: pathlib.Path,\n) -&gt; RenderCVDataModel:\n    \"\"\"Read the input file and return two instances of RenderCVDataModel. The first\n    instance is the data model with $\\\\LaTeX$ strings and the second instance is the\n    data model with markdown strings.\n\n    Args:\n        file_path (str): The path to the input file.\n\n    Returns:\n        tuple[RenderCVDataModel, RenderCVDataModel]: The data models with $\\\\LaTeX$ and\n        markdown strings.\n    \"\"\"\n    # check if the file exists:\n    if not file_path.exists():\n        raise FileNotFoundError(\n            f\"The input file [magenta]{file_path}[/magenta] doesn't exist!\"\n        )\n\n    # check the file extension:\n    accepted_extensions = [\".yaml\", \".yml\", \".json\", \".json5\"]\n    if file_path.suffix not in accepted_extensions:\n        user_friendly_accepted_extensions = [\n            f\"[green]{ext}[/green]\" for ext in accepted_extensions\n        ]\n        user_friendly_accepted_extensions = \", \".join(user_friendly_accepted_extensions)\n        raise ValueError(\n            \"The input file should have one of the following extensions:\"\n            f\" {user_friendly_accepted_extensions}. The input file is\"\n            f\" [magenta]{file_path}[/magenta].\"\n        )\n\n    file_content = file_path.read_text(encoding=\"utf-8\")\n    input_as_dictionary: dict[str, Any] = ruamel.yaml.YAML().load(file_content)  # type: ignore\n\n    # validate the parsed dictionary by creating an instance of RenderCVDataModel:\n    rendercv_data_model = RenderCVDataModel(**input_as_dictionary)\n\n    return rendercv_data_model\n</code></pre>"},{"location":"reference/data_models/#rendercv.data_models.get_a_sample_data_model","title":"<code>get_a_sample_data_model(name='John Doe', theme='classic')</code>","text":"<p>Return a sample data model for new users to start with.</p> <p>Parameters:</p> <ul> <li> <code>name</code>             (<code>str</code>, default:                 <code>'John Doe'</code> )         \u2013          <p>The name of the person. Defaults to \"John Doe\".</p> </li> </ul> <p>Returns:     RenderCVDataModel: A sample data model.</p> Source code in <code>rendercv/data_models.py</code> <pre><code>def get_a_sample_data_model(\n    name: str = \"John Doe\", theme: str = \"classic\"\n) -&gt; RenderCVDataModel:\n    \"\"\"Return a sample data model for new users to start with.\n\n    Args:\n        name (str, optional): The name of the person. Defaults to \"John Doe\".\n    Returns:\n        RenderCVDataModel: A sample data model.\n    \"\"\"\n    name = name.encode().decode(\"unicode-escape\")\n    sections = {\n        \"summary\": [\n            (\n                \"This is an example resume to showcase the capabilities of the\"\n                \" open-source LaTeX CV generator,\"\n                \" [RenderCV](https://github.com/sinaatalay/rendercv). A substantial\"\n                \" part of the content is taken from\"\n                \" [here](https://www.careercup.com/resume), where a *clean and tidy CV*\"\n                \" pattern is proposed by **Gayle L. McDowell**.\"\n            ),\n        ],\n        \"education\": [\n            EducationEntry(\n                institution=\"University of Pennsylvania\",\n                area=\"Computer Science\",\n                degree=\"BS\",\n                start_date=\"2000-09\",\n                end_date=\"2005-05\",\n                highlights=[\n                    \"GPA: 3.9/4.0 ([Transcript](https://example.com))\",\n                    (\n                        \"**Coursework:** Software Foundations, Computer\"\n                        \" Architecture, Algorithms, Artificial Intelligence, Comparison\"\n                        \" of Learning Algorithms, Computational Theory.\"\n                    ),\n                ],\n            ),\n        ],\n        \"experience\": [\n            ExperienceEntry(\n                company=\"Apple Computer\",\n                position=\"Software Engineer, Intern\",\n                start_date=\"2004-06\",\n                end_date=\"2004-08\",\n                location=\"CA, USA\",\n                highlights=[\n                    (\n                        \"Reduced time to render the user's buddy list by 75% by\"\n                        \" implementing a prediction algorithm.\"\n                    ),\n                    (\n                        \"Implemented iChat integration with OS X Spotlight Search by\"\n                        \" creating a tool that extracts metadata from saved chat\"\n                        \" transcripts and provides metadata to a system-wide search\"\n                        \" database.\"\n                    ),\n                    (\n                        \"Redesigned chat file format and implemented backward\"\n                        \" compatibility for search.\"\n                    ),\n                ],\n            ),\n            ExperienceEntry(\n                company=\"Microsoft Corporation\",\n                position=\"Lead Student Ambassador\",\n                start_date=\"2003-09\",\n                end_date=\"2005-04\",\n                location=\"WA, USA\",\n                highlights=[\n                    (\n                        \"Promoted to Lead Student Ambassador in the Fall of 2004,\"\n                        \" supervised 10 - 15 Student Ambassadors.\"\n                    ),\n                    (\n                        \"Created and taught a computer science course, CSE 099:\"\n                        \" Software Design and Development.\"\n                    ),\n                ],\n            ),\n            ExperienceEntry(\n                company=\"University of Pennsylvania\",\n                position=\"Head Teaching Assistant\",\n                start_date=\"2001-10\",\n                end_date=\"2005-05\",\n                location=\"PA, USA\",\n                highlights=[\n                    (\n                        \"Implemented a user interface for the VS open file switcher\"\n                        \" (ctrl-tab) and extended it to tool windows.\"\n                    ),\n                    (\n                        \"Created a service to provide gradient across VS and VS\"\n                        \" add-ins. Optimized service via caching.\"\n                    ),\n                    \"Programmer Productivity Research Center (Summers 2001, 2002)\",\n                    (\n                        \"Built app to compute the similarity of all methods in a code\"\n                        \" base, reduced time from $\\\\mathcal{O}(n^2)$ to\"\n                        \" $\\\\mathcal{O}(n \\\\log n)$. \"\n                    ),\n                    (\n                        \"Created a test case generation tool that creates random XML\"\n                        \" docs from XML Schema.\"\n                    ),\n                ],\n            ),\n            ExperienceEntry(\n                company=\"Microsoft Corporation\",\n                position=\"Software Design Engineer, Intern\",\n                start_date=\"2003-06\",\n                end_date=\"2003-08\",\n                location=\"WA, USA\",\n                highlights=[\n                    (\n                        \"Promoted to Lead Student Ambassador in the Fall of 2004,\"\n                        \" supervised 10 - 15 Student Ambassadors.\"\n                    ),\n                ],\n            ),\n        ],\n        \"publications\": [\n            PublicationEntry(\n                title=(\n                    \"Magneto-Thermal Thin Shell Approximation for 3D Finite Element\"\n                    \" Analysis of No-Insulation Coils\"\n                ),\n                authors=[\n                    \"Albert Smith\",\n                    name,\n                    \"Jane Derry\",\n                    \"Harry Tom\",\n                    \"Anotherfirstname Andsurname\",\n                ],\n                date=\"2004-01\",\n                doi=\"10.1109/TASC.2023.3340648\",\n            )\n        ],\n        \"projects\": [\n            NormalEntry(\n                name=\"Multi-User Drawing Tool\",\n                date=\"2004\",\n                highlights=[\n                    (\n                        \"Developed an electronic classroom where multiple users can\"\n                        ' view and simultaneously draw on a \"chalkboard\" with each'\n                        \" person's edits synchronized.\"\n                    ),\n                    \"Used C++ and MFC.\",\n                ],\n            ),\n            NormalEntry(\n                name=\"Synchronized Calendar\",\n                start_date=\"2003\",\n                end_date=\"2004\",\n                highlights=[\n                    (\n                        \"Developed a desktop calendar with globally shared and\"\n                        \" synchronized calendars, allowing users to schedule meetings\"\n                        \" with other users.\"\n                    ),\n                    \"Used C#.NET, SQL, and XML.\",\n                ],\n            ),\n            NormalEntry(\n                name=\"Operating System\",\n                date=\"2002\",\n                highlights=[\n                    (\n                        \"Developed a UNIX-style OS with a scheduler, file system, text\"\n                        \" editor, and calculator.\"\n                    ),\n                    \"Used C.\",\n                ],\n            ),\n        ],\n        \"additional_experience_and_awards\": [\n            OneLineEntry(\n                label=\"Instructor (2003 - 2005)\",\n                details=\"Taught two full-credit Computer Science courses.\",\n            ),\n            OneLineEntry(\n                label=\"Third Prize, Senior Design Projects\",\n                details=(\n                    \"Awarded 3rd prize for a synchronized calendar project out of 100\"\n                    \" projects.\"\n                ),\n            ),\n        ],\n        \"technologies\": [\n            OneLineEntry(\n                label=\"Languages\",\n                details=\"C++, C, Java, Objective-C, C#.NET, SQL, JavaScript\",\n            ),\n            OneLineEntry(\n                label=\"Software\",\n                details=(\n                    \"Visual Studio, Microsoft SQL Server, Eclipse, XCode, Interface\"\n                    \" Builder\"\n                ),\n            ),\n        ],\n    }\n\n    cv = CurriculumVitae(\n        name=name,\n        location=\"Your Location\",\n        email=\"youremail@yourdomain.com\",\n        phone=\"+905419999999\",  # type: ignore\n        website=\"https://yourwebsite.com\",  # type: ignore\n        social_networks=[\n            SocialNetwork(network=\"LinkedIn\", username=\"yourusername\"),\n            SocialNetwork(network=\"GitHub\", username=\"yourusername\"),\n        ],\n        sections=sections,  # type: ignore\n    )\n\n    if theme not in available_themes:\n        raise ValueError(\n            f\"The theme should be one of the following: {available_themes}! The\"\n            f\" provided theme is {theme}.\"\n        )\n\n    if theme == \"classic\":\n        design = ClassicThemeOptions(theme=\"classic\", show_timespan_in=[\"Experience\"])\n    else:\n        design = rendercv_design_validator.validate_python({\"theme\": theme})  # type: ignore\n\n    return RenderCVDataModel(cv=cv, design=design)\n</code></pre>"},{"location":"reference/data_models/#rendercv.data_models.generate_json_schema","title":"<code>generate_json_schema()</code>","text":"<p>Generate the JSON schema of RenderCV.</p> <p>JSON schema is generated for the users to make it easier for them to write the input file. The JSON Schema of RenderCV is saved in the <code>docs</code> directory of the repository and distributed to the users with the JSON Schema Store.</p> <p>Returns:</p> <ul> <li> <code>dict</code> (            <code>dict[str, Any]</code> )        \u2013          <p>The JSON schema of RenderCV.</p> </li> </ul> Source code in <code>rendercv/data_models.py</code> <pre><code>def generate_json_schema() -&gt; dict[str, Any]:\n    \"\"\"Generate the JSON schema of RenderCV.\n\n    JSON schema is generated for the users to make it easier for them to write the input\n    file. The JSON Schema of RenderCV is saved in the `docs` directory of the repository\n    and distributed to the users with the\n    [JSON Schema Store](https://www.schemastore.org/).\n\n    Returns:\n        dict: The JSON schema of RenderCV.\n    \"\"\"\n\n    class RenderCVSchemaGenerator(pydantic.json_schema.GenerateJsonSchema):\n        def generate(self, schema, mode=\"validation\"):  # type: ignore\n            json_schema = super().generate(schema, mode=mode)\n\n            # Basic information about the schema:\n            json_schema[\"title\"] = \"RenderCV\"\n            json_schema[\"description\"] = \"RenderCV data model.\"\n            json_schema[\"$id\"] = (\n                \"https://raw.githubusercontent.com/sinaatalay/rendercv/main/schema.json\"\n            )\n            json_schema[\"$schema\"] = \"http://json-schema.org/draft-07/schema#\"\n\n            # Loop through $defs and remove docstring descriptions and fix optional\n            # fields\n            for _, value in json_schema[\"$defs\"].items():\n                # Don't allow additional properties\n                value[\"additionalProperties\"] = False\n\n                # If a type is optional, then Pydantic sets the type to a list of two\n                # types, one of which is null. The null type can be removed since we\n                # already have the required field. Moreover, we would like to warn\n                # users if they provide null values. They can remove the fields if they\n                # don't want to provide them.\n                null_type_dict = {}\n                null_type_dict[\"type\"] = \"null\"\n                for field in value[\"properties\"].values():\n                    if \"anyOf\" in field:\n                        if (\n                            len(field[\"anyOf\"]) == 2\n                            and null_type_dict in field[\"anyOf\"]\n                        ):\n                            field[\"allOf\"] = [field[\"anyOf\"][0]]\n                            del field[\"anyOf\"]\n                        else:\n                            field[\"oneOf\"] = field[\"anyOf\"]\n                            del field[\"anyOf\"]\n\n                # In date field, we both accept normal strings and Date objects. They\n                # are both strings, therefore, if user provides a Date object, then\n                # JSON schema will complain that it matches two different types.\n                # Remember that all of the anyOfs are changed to oneOfs. Only one of\n                # the types can be matched. Therefore, we remove the first type, which\n                # is the string with the YYYY-MM-DD format.\n                if (\n                    \"date\" in value[\"properties\"]\n                    and \"oneOf\" in value[\"properties\"][\"date\"]\n                ):\n                    del value[\"properties\"][\"date\"][\"oneOf\"][0]\n\n            return json_schema\n\n    schema = RenderCVDataModel.model_json_schema(\n        schema_generator=RenderCVSchemaGenerator\n    )\n\n    return schema\n</code></pre>"},{"location":"reference/data_models/#rendercv.data_models.generate_json_schema_file","title":"<code>generate_json_schema_file(json_schema_path)</code>","text":"<p>Generate the JSON schema of RenderCV and save it to a file.</p> <p>Parameters:</p> <ul> <li> <code>json_schema_path</code>             (<code>Path</code>)         \u2013          <p>The path to save the JSON schema.</p> </li> </ul> Source code in <code>rendercv/data_models.py</code> <pre><code>def generate_json_schema_file(json_schema_path: pathlib.Path):\n    \"\"\"Generate the JSON schema of RenderCV and save it to a file.\n\n    Args:\n        json_schema_path (pathlib.Path): The path to save the JSON schema.\n    \"\"\"\n    schema = generate_json_schema()\n    schema_json = json.dumps(schema, indent=2)\n    json_schema_path.write_text(schema_json)\n</code></pre>"},{"location":"reference/renderer/","title":"Renderer","text":"<p>This module contains functions and classes for generating a $\\LaTeX$ file from the data model and rendering the $\\LaTeX$ file to produce a PDF.</p> <p>The $\\LaTeX$ files are generated with Jinja2 templates. Then, the $\\LaTeX$ file is rendered into a PDF with TinyTeX, a $\\LaTeX$ distribution.</p>"},{"location":"reference/renderer/#rendercv.renderer.TemplatedFile","title":"<code>TemplatedFile(data_model, environment)</code>","text":"<p>This class is a base class for LaTeXFile and MarkdownFile classes. It contains the common methods and attributes for both classes. These classes are used to generate the $\\LaTeX$ and Markdown files with the data model and Jinja2 templates.</p> <p>Parameters:</p> <ul> <li> <code>data_model</code>             (<code>RenderCVDataModel</code>)         \u2013          <p>The data model.</p> </li> <li> <code>environment</code>             (<code>Environment</code>)         \u2013          <p>The Jinja2 environment.</p> </li> </ul> Source code in <code>rendercv/renderer.py</code> <pre><code>def __init__(\n    self,\n    data_model: dm.RenderCVDataModel,\n    environment: jinja2.Environment,\n):\n    self.cv = data_model.cv\n    self.design = data_model.design\n    self.environment = environment\n</code></pre>"},{"location":"reference/renderer/#rendercv.renderer.TemplatedFile.template","title":"<code>template(theme_name, template_name, extension, entry=None, section_title=None, is_first_entry=None)</code>","text":"<p>Template one of the files in the <code>themes</code> directory.</p> <p>Parameters:</p> <ul> <li> <code>template_name</code>             (<code>str</code>)         \u2013          <p>The name of the template file.</p> </li> <li> <code>entry</code>             (<code>Optional[Entry]</code>, default:                 <code>None</code> )         \u2013          <p>The title of the section.</p> </li> <li> <code>is_first_entry</code>             (<code>Optional[bool]</code>, default:                 <code>None</code> )         \u2013          <p>Whether the entry is the first one in the section.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code> (            <code>str</code> )        \u2013          <p>The templated file.</p> </li> </ul> Source code in <code>rendercv/renderer.py</code> <pre><code>def template(\n    self,\n    theme_name: str,\n    template_name: str,\n    extension: str,\n    entry: Optional[dm.Entry] = None,\n    section_title: Optional[str] = None,\n    is_first_entry: Optional[bool] = None,\n) -&gt; str:\n    \"\"\"Template one of the files in the `themes` directory.\n\n    Args:\n        template_name (str): The name of the template file.\n        entry (Optional[dm.Entry]): The title of the section.\n        is_first_entry (Optional[bool]): Whether the entry is the first one in the\n            section.\n\n    Returns:\n        str: The templated file.\n    \"\"\"\n    template = self.environment.get_template(\n        f\"{theme_name}/{template_name}.j2.{extension}\"\n    )\n\n    # Loop through the entry attributes and make them \"\" if they are None:\n    # This is necessary because otherwise they will be templated as \"None\" since\n    # it's the string representation of None.\n\n    # Only don't touch the date fields, because only date_string is called and\n    # setting dates to \"\" will cause problems.\n    fields_to_ignore = [\"start_date\", \"end_date\", \"date\"]\n\n    if entry is not None and not isinstance(entry, str):\n        entry_dictionary = entry.model_dump()\n        for key, value in entry_dictionary.items():\n            if value is None and key not in fields_to_ignore:\n                entry.__setattr__(key, \"\")\n\n    # The arguments of the template can be used in the template file:\n    result = template.render(\n        cv=self.cv,\n        design=self.design,\n        entry=entry,\n        section_title=section_title,\n        today=Date.today().strftime(\"%B %Y\"),\n        is_first_entry=is_first_entry,\n    )\n\n    return result\n</code></pre>"},{"location":"reference/renderer/#rendercv.renderer.TemplatedFile.get_full_code","title":"<code>get_full_code(main_template_name, **kwargs)</code>","text":"<p>Combine all the templates to get the full code of the file.</p> Source code in <code>rendercv/renderer.py</code> <pre><code>def get_full_code(self, main_template_name: str, **kwargs) -&gt; str:\n    \"\"\"Combine all the templates to get the full code of the file.\"\"\"\n    main_template = self.environment.get_template(main_template_name)\n    latex_code = main_template.render(\n        **kwargs,\n    )\n    return latex_code\n</code></pre>"},{"location":"reference/renderer/#rendercv.renderer.LaTeXFile","title":"<code>LaTeXFile(data_model, environment)</code>","text":"<p>             Bases: <code>TemplatedFile</code></p> <p>This class represents a $\\LaTeX$ file. It generates the $\\LaTeX$ code with the data model and Jinja2 templates. It inherits from the TemplatedFile class.</p> Source code in <code>rendercv/renderer.py</code> <pre><code>def __init__(\n    self,\n    data_model: dm.RenderCVDataModel,\n    environment: jinja2.Environment,\n):\n    latex_file_data_model = copy.deepcopy(data_model)\n    transformed_sections = transform_markdown_sections_to_latex_sections(\n        latex_file_data_model.cv.sections_input\n    )\n    latex_file_data_model.cv.sections_input = transformed_sections\n    super().__init__(latex_file_data_model, environment)\n</code></pre>"},{"location":"reference/renderer/#rendercv.renderer.LaTeXFile.render_templates","title":"<code>render_templates()</code>","text":"<p>Render and return all the templates for the $\\LaTeX$ file.</p> <p>Returns:</p> <ul> <li> <code>tuple[str, str, list[tuple[str, list[str], str]]]</code>         \u2013          <p>Tuple[str, str, List[Tuple[str, List[str], str]]]: The preamble, header, and sections of the $\\LaTeX$ file.</p> </li> </ul> Source code in <code>rendercv/renderer.py</code> <pre><code>def render_templates(self) -&gt; tuple[str, str, list[tuple[str, list[str], str]]]:\n    \"\"\"Render and return all the templates for the $\\\\LaTeX$ file.\n\n    Returns:\n        Tuple[str, str, List[Tuple[str, List[str], str]]]: The preamble, header, and\n            sections of the $\\\\LaTeX$ file.\n    \"\"\"\n    # Template the preamble, header, and sections:\n    preamble = self.template(\"Preamble\")\n    header = self.template(\"Header\")\n    sections: list[tuple[str, list[str], str]] = []\n    for section in self.cv.sections:\n        section_beginning = self.template(\n            \"SectionBeginning\", section_title=section.title\n        )\n        entries: list[str] = []\n        for i, entry in enumerate(section.entries):\n            is_first_entry = i == 0\n\n            entries.append(\n                self.template(\n                    section.entry_type,\n                    entry=entry,\n                    section_title=section.title,\n                    is_first_entry=is_first_entry,\n                )\n            )\n        section_ending = self.template(\"SectionEnding\", section_title=section.title)\n        sections.append((section_beginning, entries, section_ending))\n\n    return preamble, header, sections\n</code></pre>"},{"location":"reference/renderer/#rendercv.renderer.LaTeXFile.template","title":"<code>template(template_name, entry=None, section_title=None, is_first_entry=None)</code>","text":"<p>Template one of the files in the <code>themes</code> directory.</p> <p>Parameters:</p> <ul> <li> <code>template_name</code>             (<code>str</code>)         \u2013          <p>The name of the template file.</p> </li> <li> <code>entry</code>             (<code>Optional[Entry]</code>, default:                 <code>None</code> )         \u2013          <p>The data model of the entry.</p> </li> <li> <code>section_title</code>             (<code>Optional[str]</code>, default:                 <code>None</code> )         \u2013          <p>The title of the section.</p> </li> <li> <code>is_first_entry</code>             (<code>Optional[bool]</code>, default:                 <code>None</code> )         \u2013          <p>Whether the entry is the first one in the section.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code> (            <code>str</code> )        \u2013          <p>The templated file.</p> </li> </ul> Source code in <code>rendercv/renderer.py</code> <pre><code>def template(\n    self,\n    template_name: str,\n    entry: Optional[dm.Entry] = None,\n    section_title: Optional[str] = None,\n    is_first_entry: Optional[bool] = None,\n) -&gt; str:\n    \"\"\"Template one of the files in the `themes` directory.\n\n    Args:\n        template_name (str): The name of the template file.\n        entry (Optional[dm.Entry]): The data model of the entry.\n        section_title (Optional[str]): The title of the section.\n        is_first_entry (Optional[bool]): Whether the entry is the first one in the section.\n\n    Returns:\n        str: The templated file.\n    \"\"\"\n    result = super().template(\n        self.design.theme,\n        template_name,\n        \"tex\",\n        entry,\n        section_title,\n        is_first_entry,\n    )\n\n    # If there is nested \\textbf, \\textit, or \\underline commands, replace the inner\n    # ones with \\textnormal:\n\n    # Find all the nested commands:\n    nested_commands = re.findall(r\"\\\\textbf{[^}]*?(\\\\textbf{.*?})\", result)\n    nested_commands += re.findall(r\"\\\\textit{[^}]*?(\\\\textit{.*?})\", result)\n    nested_commands += re.findall(r\"\\\\underline{[^}]*?(\\\\underline{.*?})\", result)\n\n    # Replace the inner commands with \\textnormal:\n    for nested_command in nested_commands:\n        new_command = nested_command.replace(\"textbf\", \"textnormal\")\n        new_command = new_command.replace(\"textit\", \"textnormal\")\n        new_command = new_command.replace(\"underline\", \"textnormal\")\n        result = result.replace(nested_command, new_command)\n\n    return result\n</code></pre>"},{"location":"reference/renderer/#rendercv.renderer.LaTeXFile.get_latex_code","title":"<code>get_latex_code()</code>","text":"<p>Get the $\\LaTeX$ code of the file.</p> <p>Returns:</p> <ul> <li> <code>str</code>        \u2013          <p>The $\\LaTeX$ code.</p> </li> </ul> Source code in <code>rendercv/renderer.py</code> <pre><code>def get_latex_code(self):\n    \"\"\"Get the $\\\\LaTeX$ code of the file.\n\n    Returns:\n        str: The $\\\\LaTeX$ code.\n    \"\"\"\n    preamble, header, sections = self.render_templates()\n    latex_code: str = self.get_full_code(\n        \"main.j2.tex\",\n        preamble=preamble,\n        header=header,\n        sections=sections,\n    )\n    return latex_code\n</code></pre>"},{"location":"reference/renderer/#rendercv.renderer.LaTeXFile.generate_latex_file","title":"<code>generate_latex_file(file_path)</code>","text":"<p>Write the $\\LaTeX$ code to a file.</p> Source code in <code>rendercv/renderer.py</code> <pre><code>def generate_latex_file(self, file_path: pathlib.Path):\n    \"\"\"Write the $\\\\LaTeX$ code to a file.\"\"\"\n    file_path.write_text(self.get_latex_code(), encoding=\"utf-8\")\n</code></pre>"},{"location":"reference/renderer/#rendercv.renderer.MarkdownFile","title":"<code>MarkdownFile(data_model, environment)</code>","text":"<p>             Bases: <code>TemplatedFile</code></p> <p>This class represents a Markdown file. It generates the Markdown code with the data model and Jinja2 templates. It inherits from the TemplatedFile class. Markdown files are generated to produce a PDF which can be copy-pasted to Grammarly for proofreading.</p> Source code in <code>rendercv/renderer.py</code> <pre><code>def __init__(\n    self,\n    data_model: dm.RenderCVDataModel,\n    environment: jinja2.Environment,\n):\n    self.cv = data_model.cv\n    self.design = data_model.design\n    self.environment = environment\n</code></pre>"},{"location":"reference/renderer/#rendercv.renderer.MarkdownFile.render_templates","title":"<code>render_templates()</code>","text":"<p>Render and return all the templates for the Markdown file.</p> <p>Returns:</p> <ul> <li>         \u2013          <p>tuple[str, List[Tuple[str, List[str]]]]: The header and sections of the Markdown file.</p> </li> </ul> Source code in <code>rendercv/renderer.py</code> <pre><code>def render_templates(self):\n    \"\"\"Render and return all the templates for the Markdown file.\n\n    Returns:\n        tuple[str, List[Tuple[str, List[str]]]]: The header and sections of the Markdown file.\n    \"\"\"\n    # Template the header and sections:\n    header = self.template(\"Header\")\n    sections: list[tuple[str, list[str]]] = []\n    for section in self.cv.sections:\n        section_beginning = self.template(\n            \"SectionBeginning\", section_title=section.title\n        )\n        entries: list[str] = []\n        for i, entry in enumerate(section.entries):\n            if i == 0:\n                is_first_entry = True\n            else:\n                is_first_entry = False\n            entries.append(\n                self.template(\n                    section.entry_type,\n                    entry=entry,\n                    section_title=section.title,\n                    is_first_entry=is_first_entry,\n                )\n            )\n        sections.append((section_beginning, entries))\n\n    result: tuple[str, list[tuple[str, list[str]]]] = (header, sections)\n    return result\n</code></pre>"},{"location":"reference/renderer/#rendercv.renderer.MarkdownFile.template","title":"<code>template(template_name, entry=None, section_title=None, is_first_entry=None)</code>","text":"<p>Template one of the files in the <code>themes</code> directory.</p> <p>Parameters:</p> <ul> <li> <code>template_name</code>             (<code>str</code>)         \u2013          <p>The name of the template file.</p> </li> <li> <code>entry</code>             (<code>Optional[Entry]</code>, default:                 <code>None</code> )         \u2013          <p>The data model of the entry.</p> </li> <li> <code>section_title</code>             (<code>Optional[str]</code>, default:                 <code>None</code> )         \u2013          <p>The title of the section.</p> </li> <li> <code>is_first_entry</code>             (<code>Optional[bool]</code>, default:                 <code>None</code> )         \u2013          <p>Whether the entry is the first one in the section.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code> (            <code>str</code> )        \u2013          <p>The templated file.</p> </li> </ul> Source code in <code>rendercv/renderer.py</code> <pre><code>def template(\n    self,\n    template_name: str,\n    entry: Optional[dm.Entry] = None,\n    section_title: Optional[str] = None,\n    is_first_entry: Optional[bool] = None,\n) -&gt; str:\n    \"\"\"Template one of the files in the `themes` directory.\n\n    Args:\n        template_name (str): The name of the template file.\n        entry (Optional[dm.Entry]): The data model of the entry.\n        section_title (Optional[str]): The title of the section.\n        is_first_entry (Optional[bool]): Whether the entry is the first one in the\n            section.\n\n    Returns:\n        str: The templated file.\n    \"\"\"\n    result = super().template(\n        \"markdown\",\n        template_name,\n        \"md\",\n        entry,\n        section_title,\n        is_first_entry,\n    )\n    return result\n</code></pre>"},{"location":"reference/renderer/#rendercv.renderer.MarkdownFile.get_markdown_code","title":"<code>get_markdown_code()</code>","text":"<p>Get the Markdown code of the file.</p> <p>Returns:</p> <ul> <li> <code>str</code>        \u2013          <p>The Markdown code.</p> </li> </ul> Source code in <code>rendercv/renderer.py</code> <pre><code>def get_markdown_code(self):\n    \"\"\"Get the Markdown code of the file.\n\n    Returns:\n        str: The Markdown code.\n    \"\"\"\n    header, sections = self.render_templates()\n    markdown_code: str = self.get_full_code(\n        \"main.j2.md\",\n        header=header,\n        sections=sections,\n    )\n    return markdown_code\n</code></pre>"},{"location":"reference/renderer/#rendercv.renderer.MarkdownFile.generate_markdown_file","title":"<code>generate_markdown_file(file_path)</code>","text":"<p>Write the Markdown code to a file.</p> Source code in <code>rendercv/renderer.py</code> <pre><code>def generate_markdown_file(self, file_path: pathlib.Path):\n    \"\"\"Write the Markdown code to a file.\"\"\"\n    file_path.write_text(self.get_markdown_code(), encoding=\"utf-8\")\n</code></pre>"},{"location":"reference/renderer/#rendercv.renderer.escape_latex_characters","title":"<code>escape_latex_characters(string, strict=True)</code>","text":"<p>Escape $\\LaTeX$ characters in a string.</p> <p>This function is called during the reading of the input file. Before the validation process, each input field's special $\\LaTeX$ characters are escaped. It is also can be used as a Jinja2 filter in templates.</p> Example <p><pre><code>escape_latex_characters(\"This is a # string.\")\n</code></pre> will return: <code>\"This is a \\# string.\"</code></p> <p>Parameters:</p> <ul> <li> <code>string</code>             (<code>str</code>)         \u2013          <p>The string to escape.</p> </li> <li> <code>strict</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to escape all the special $\\LaTeX$ characters or not. If you want to allow math input, set it to False.</p> </li> </ul> <p>Returns:     str: The escaped string.</p> Source code in <code>rendercv/renderer.py</code> <pre><code>def escape_latex_characters(string: str, strict: bool = True) -&gt; str:\n    \"\"\"Escape $\\\\LaTeX$ characters in a string.\n\n    This function is called during the reading of the input file. Before the validation\n    process, each input field's special $\\\\LaTeX$ characters are escaped. It is also can\n    be used as a Jinja2 filter in templates.\n\n    Example:\n        ```python\n        escape_latex_characters(\"This is a # string.\")\n        ```\n        will return:\n        `#!python \"This is a \\\\# string.\"`\n\n    Args:\n        string (str): The string to escape.\n        strict (bool): Whether to escape all the special $\\\\LaTeX$ characters or not. If\n            you want to allow math input, set it to False.\n    Returns:\n        str: The escaped string.\n    \"\"\"\n\n    # Dictionary of escape characters:\n    escape_characters = {\n        \"#\": \"\\\\#\",\n        \"%\": \"\\\\%\",\n        \"&amp;\": \"\\\\&amp;\",\n        \"~\": \"\\\\textasciitilde{}\",\n    }\n\n    if strict:\n        # To allow math input, users can use this function with strict = False\n        escape_characters[\"$\"] = \"\\\\$\"\n        escape_characters[\"_\"] = \"\\\\_\"\n        escape_characters[\"^\"] = \"\\\\textasciicircum{}\"\n\n    # Don't escape links as hyperref package will do it automatically:\n    # Find all the links in the sentence:\n    links = re.findall(r\"\\[.*?\\]\\(.*?\\)\", string)\n\n    # Replace the links with a placeholder:\n    for i, link in enumerate(links):\n        string = string.replace(link, f\"!!-link{i}-!!\")\n\n    # Loop through the letters of the sentence and if you find an escape character,\n    # replace it with its LaTeX equivalent:\n    copy_of_the_string = list(string)\n    for i, character in enumerate(copy_of_the_string):\n        if character in escape_characters:\n            new_character = escape_characters[character]\n            copy_of_the_string[i] = new_character\n\n    string = \"\".join(copy_of_the_string)\n    # Replace the links with the original links:\n    for i, link in enumerate(links):\n        string = string.replace(f\"!!-link{i}-!!\", link)\n\n    return string\n</code></pre>"},{"location":"reference/renderer/#rendercv.renderer.markdown_to_latex","title":"<code>markdown_to_latex(markdown_string)</code>","text":"<p>Convert a markdown string to LaTeX.</p> <p>This function is called during the reading of the input file. Before the validation process, each input field is converted from markdown to LaTeX.</p> Example <pre><code>markdown_to_latex(\"This is a **bold** text with an [*italic link*](https://google.com).\")\n</code></pre> <p>will return:</p> <p><code>\"This is a \\textbf{bold} text with a \\href{https://google.com}{\\textit{link}}.\"</code></p> <p>Parameters:</p> <ul> <li> <code>markdown_string</code>             (<code>str</code>)         \u2013          <p>The markdown string to convert.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code> (            <code>str</code> )        \u2013          <p>The $\\LaTeX$ string.</p> </li> </ul> Source code in <code>rendercv/renderer.py</code> <pre><code>def markdown_to_latex(markdown_string: str) -&gt; str:\n    \"\"\"Convert a markdown string to LaTeX.\n\n    This function is called during the reading of the input file. Before the validation\n    process, each input field is converted from markdown to LaTeX.\n\n    Example:\n        ```python\n        markdown_to_latex(\"This is a **bold** text with an [*italic link*](https://google.com).\")\n        ```\n\n        will return:\n\n        `#!python \"This is a \\\\textbf{bold} text with a \\\\href{https://google.com}{\\\\textit{link}}.\"`\n\n    Args:\n        markdown_string (str): The markdown string to convert.\n\n    Returns:\n        str: The $\\\\LaTeX$ string.\n    \"\"\"\n    # convert links\n    links = re.findall(r\"\\[([^\\]\\[]*)\\]\\((.*?)\\)\", markdown_string)\n    if links is not None:\n        for link in links:\n            link_text = link[0]\n            link_url = link[1]\n\n            old_link_string = f\"[{link_text}]({link_url})\"\n            new_link_string = \"\\\\href{\" + link_url + \"}{\" + link_text + \"}\"\n\n            markdown_string = markdown_string.replace(old_link_string, new_link_string)\n\n    # convert bold\n    bolds = re.findall(r\"\\*\\*(.+?)\\*\\*\", markdown_string)\n    if bolds is not None:\n        for bold_text in bolds:\n            old_bold_text = f\"**{bold_text}**\"\n            new_bold_text = \"\\\\textbf{\" + bold_text + \"}\"\n\n            markdown_string = markdown_string.replace(old_bold_text, new_bold_text)\n\n    # convert italic\n    italics = re.findall(r\"\\*(.+?)\\*\", markdown_string)\n    if italics is not None:\n        for italic_text in italics:\n            old_italic_text = f\"*{italic_text}*\"\n            new_italic_text = \"\\\\textit{\" + italic_text + \"}\"\n\n            markdown_string = markdown_string.replace(old_italic_text, new_italic_text)\n\n    # convert code\n    # not supported by rendercv currently\n    # codes = re.findall(r\"`([^`]*)`\", markdown_string)\n    # if codes is not None:\n    #     for code_text in codes:\n    #         old_code_text = f\"`{code_text}`\"\n    #         new_code_text = \"\\\\texttt{\" + code_text + \"}\"\n\n    #         markdown_string = markdown_string.replace(old_code_text, new_code_text)\n\n    latex_string = markdown_string\n\n    return latex_string\n</code></pre>"},{"location":"reference/renderer/#rendercv.renderer.transform_markdown_sections_to_latex_sections","title":"<code>transform_markdown_sections_to_latex_sections(sections)</code>","text":"<p>Recursively loop through sections and convert all the markdown strings (user input is in markdown format) to $\\LaTeX$ strings. Also, escape special $\\LaTeX$ characters.</p> <p>Parameters:</p> <ul> <li> <code>sections</code>             (<code>Optional[dict[str, SectionInput]]</code>)         \u2013          <p>Sections with markdown strings.</p> </li> </ul> <p>Returns:     Optional[dict[str, dm.SectionInput]]: Sections with $\\LaTeX$ strings.</p> Source code in <code>rendercv/renderer.py</code> <pre><code>def transform_markdown_sections_to_latex_sections(\n    sections: Optional[dict[str, dm.SectionInput]],\n) -&gt; Optional[dict[str, dm.SectionInput]]:\n    \"\"\"\n    Recursively loop through sections and convert all the markdown strings (user input\n    is in markdown format) to $\\\\LaTeX$ strings. Also, escape special $\\\\LaTeX$\n    characters.\n\n    Args:\n        sections (Optional[dict[str, dm.SectionInput]]): Sections with markdown strings.\n    Returns:\n        Optional[dict[str, dm.SectionInput]]: Sections with $\\\\LaTeX$ strings.\n    \"\"\"\n    if sections is None:\n        return None\n\n    for key, value in sections.items():\n        # loop through the list and apply markdown_to_latex and escape_latex_characters\n        # to each item:\n        transformed_list = []\n        for entry in value:\n            if isinstance(entry, str):\n                # Then it means it's a TextEntry.\n                result = markdown_to_latex(escape_latex_characters(entry, strict=False))\n                transformed_list.append(result)\n            else:\n                # Then it means it's one of the other entries.\n                entry_as_dict = entry.model_dump()\n                for entry_key, value in entry_as_dict.items():\n                    if isinstance(value, str):\n                        result = markdown_to_latex(\n                            escape_latex_characters(value, strict=False)\n                        )\n                        setattr(entry, entry_key, result)\n                    elif isinstance(value, list):\n                        for j, item in enumerate(value):\n                            if isinstance(item, str):\n                                value[j] = markdown_to_latex(\n                                    escape_latex_characters(item, strict=False)\n                                )\n                        setattr(entry, entry_key, value)\n                transformed_list.append(entry)\n\n        sections[key] = transformed_list\n\n    return sections\n</code></pre>"},{"location":"reference/renderer/#rendercv.renderer.replace_placeholders_with_actual_values","title":"<code>replace_placeholders_with_actual_values(string, placeholders)</code>","text":"<p>Replace the placeholders in a string with actual values.</p> <p>This function can be used as a Jinja2 filter in templates.</p> <p>Parameters:</p> <ul> <li> <code>string</code>             (<code>str</code>)         \u2013          <p>The string with placeholders.</p> </li> <li> <code>placeholders</code>             (<code>dict[str, str]</code>)         \u2013          <p>The placeholders and their values.</p> </li> </ul> <p>Returns:     str: The string with actual values.</p> Source code in <code>rendercv/renderer.py</code> <pre><code>def replace_placeholders_with_actual_values(\n    string: str, placeholders: dict[str, Optional[str]]\n) -&gt; str:\n    \"\"\"Replace the placeholders in a string with actual values.\n\n    This function can be used as a Jinja2 filter in templates.\n\n    Args:\n        string (str): The string with placeholders.\n        placeholders (dict[str, str]): The placeholders and their values.\n    Returns:\n        str: The string with actual values.\n    \"\"\"\n    for placeholder, value in placeholders.items():\n        string = string.replace(placeholder, str(value))\n\n    return string\n</code></pre>"},{"location":"reference/renderer/#rendercv.renderer.make_matched_part_something","title":"<code>make_matched_part_something(value, something, match_str=None)</code>","text":"<p>Make the matched parts of the string something. If the match_str is None, the whole string will be made something.</p> Warning <p>This function shouldn't be used directly. Use make_matched_part_bold, make_matched_part_underlined, make_matched_part_italic, or make_matched_part_non_line_breakable instead.</p> <p>Parameters:</p> <ul> <li> <code>value</code>             (<code>str</code>)         \u2013          <p>The string to make something.</p> </li> <li> <code>something</code>             (<code>str</code>)         \u2013          <p>The $\\LaTeX$ command to use.</p> </li> <li> <code>match_str</code>             (<code>str</code>, default:                 <code>None</code> )         \u2013          <p>The string to match.</p> </li> </ul> <p>Returns:     str: The string with the matched part something.</p> Source code in <code>rendercv/renderer.py</code> <pre><code>def make_matched_part_something(\n    value: str, something: str, match_str: Optional[str] = None\n) -&gt; str:\n    \"\"\"Make the matched parts of the string something. If the match_str is None, the\n    whole string will be made something.\n\n    Warning:\n        This function shouldn't be used directly. Use\n        [make_matched_part_bold](renderer.md#rendercv.rendering.make_matched_part_bold),\n        [make_matched_part_underlined](renderer.md#rendercv.rendering.make_matched_part_underlined),\n        [make_matched_part_italic](renderer.md#rendercv.rendering.make_matched_part_italic),\n        or\n        [make_matched_part_non_line_breakable](renderer.md#rendercv.rendering.make_matched_part_non_line_breakable)\n        instead.\n\n    Args:\n        value (str): The string to make something.\n        something (str): The $\\\\LaTeX$ command to use.\n        match_str (str): The string to match.\n    Returns:\n        str: The string with the matched part something.\n    \"\"\"\n    if match_str is None:\n        value = f\"\\\\{something}{{{value}}}\"\n    elif match_str in value and match_str != \"\":\n        value = value.replace(match_str, f\"\\\\{something}{{{match_str}}}\")\n\n    return value\n</code></pre>"},{"location":"reference/renderer/#rendercv.renderer.make_matched_part_bold","title":"<code>make_matched_part_bold(value, match_str=None)</code>","text":"<p>Make the matched parts of the string bold. If the match_str is None, the whole string will be made bold.</p> <p>This function can be used as a Jinja2 filter in templates.</p> Example <pre><code>make_it_bold(\"Hello World!\", \"Hello\")\n</code></pre> <p>will return:</p> <p><code>\"\\textbf{Hello} World!\"</code></p> <p>Parameters:</p> <ul> <li> <code>value</code>             (<code>str</code>)         \u2013          <p>The string to make bold.</p> </li> <li> <code>match_str</code>             (<code>str</code>, default:                 <code>None</code> )         \u2013          <p>The string to match.</p> </li> </ul> <p>Returns:     str: The string with the matched part bold.</p> Source code in <code>rendercv/renderer.py</code> <pre><code>def make_matched_part_bold(value: str, match_str: Optional[str] = None) -&gt; str:\n    \"\"\"Make the matched parts of the string bold. If the match_str is None, the whole\n    string will be made bold.\n\n    This function can be used as a Jinja2 filter in templates.\n\n    Example:\n        ```python\n        make_it_bold(\"Hello World!\", \"Hello\")\n        ```\n\n        will return:\n\n        `#!python \"\\\\textbf{Hello} World!\"`\n\n    Args:\n        value (str): The string to make bold.\n        match_str (str): The string to match.\n    Returns:\n        str: The string with the matched part bold.\n    \"\"\"\n    return make_matched_part_something(value, \"textbf\", match_str)\n</code></pre>"},{"location":"reference/renderer/#rendercv.renderer.make_matched_part_underlined","title":"<code>make_matched_part_underlined(value, match_str=None)</code>","text":"<p>Make the matched parts of the string underlined. If the match_str is None, the whole string will be made underlined.</p> <p>This function can be used as a Jinja2 filter in templates.</p> Example <pre><code>make_it_underlined(\"Hello World!\", \"Hello\")\n</code></pre> <p>will return:</p> <p><code>\"\\underline{Hello} World!\"</code></p> <p>Parameters:</p> <ul> <li> <code>value</code>             (<code>str</code>)         \u2013          <p>The string to make underlined.</p> </li> <li> <code>match_str</code>             (<code>str</code>, default:                 <code>None</code> )         \u2013          <p>The string to match.</p> </li> </ul> <p>Returns:     str: The string with the matched part underlined.</p> Source code in <code>rendercv/renderer.py</code> <pre><code>def make_matched_part_underlined(value: str, match_str: Optional[str] = None) -&gt; str:\n    \"\"\"Make the matched parts of the string underlined. If the match_str is None, the\n    whole string will be made underlined.\n\n    This function can be used as a Jinja2 filter in templates.\n\n    Example:\n        ```python\n        make_it_underlined(\"Hello World!\", \"Hello\")\n        ```\n\n        will return:\n\n        `#!python \"\\\\underline{Hello} World!\"`\n\n    Args:\n        value (str): The string to make underlined.\n        match_str (str): The string to match.\n    Returns:\n        str: The string with the matched part underlined.\n    \"\"\"\n    return make_matched_part_something(value, \"underline\", match_str)\n</code></pre>"},{"location":"reference/renderer/#rendercv.renderer.make_matched_part_italic","title":"<code>make_matched_part_italic(value, match_str=None)</code>","text":"<p>Make the matched parts of the string italic. If the match_str is None, the whole string will be made italic.</p> <p>This function can be used as a Jinja2 filter in templates.</p> Example <pre><code>make_it_italic(\"Hello World!\", \"Hello\")\n</code></pre> <p>will return:</p> <p><code>\"\\textit{Hello} World!\"</code></p> <p>Parameters:</p> <ul> <li> <code>value</code>             (<code>str</code>)         \u2013          <p>The string to make italic.</p> </li> <li> <code>match_str</code>             (<code>str</code>, default:                 <code>None</code> )         \u2013          <p>The string to match.</p> </li> </ul> <p>Returns:     str: The string with the matched part italic.</p> Source code in <code>rendercv/renderer.py</code> <pre><code>def make_matched_part_italic(value: str, match_str: Optional[str] = None) -&gt; str:\n    \"\"\"Make the matched parts of the string italic. If the match_str is None, the whole\n    string will be made italic.\n\n    This function can be used as a Jinja2 filter in templates.\n\n    Example:\n        ```python\n        make_it_italic(\"Hello World!\", \"Hello\")\n        ```\n\n        will return:\n\n        `#!python \"\\\\textit{Hello} World!\"`\n\n    Args:\n        value (str): The string to make italic.\n        match_str (str): The string to match.\n    Returns:\n        str: The string with the matched part italic.\n    \"\"\"\n    return make_matched_part_something(value, \"textit\", match_str)\n</code></pre>"},{"location":"reference/renderer/#rendercv.renderer.make_matched_part_non_line_breakable","title":"<code>make_matched_part_non_line_breakable(value, match_str=None)</code>","text":"<p>Make the matched parts of the string non line breakable. If the match_str is None, the whole string will be made nonbreakable.</p> <p>This function can be used as a Jinja2 filter in templates.</p> Example <pre><code>make_it_nolinebreak(\"Hello World!\", \"Hello\")\n</code></pre> <p>will return:</p> <p><code>\"\\mbox{Hello} World!\"</code></p> <p>Parameters:</p> <ul> <li> <code>value</code>             (<code>str</code>)         \u2013          <p>The string to disable line breaks.</p> </li> <li> <code>match_str</code>             (<code>str</code>, default:                 <code>None</code> )         \u2013          <p>The string to match.</p> </li> </ul> <p>Returns:     str: The string with the matched part non line breakable.</p> Source code in <code>rendercv/renderer.py</code> <pre><code>def make_matched_part_non_line_breakable(\n    value: str, match_str: Optional[str] = None\n) -&gt; str:\n    \"\"\"Make the matched parts of the string non line breakable. If the match_str is\n    None, the whole string will be made nonbreakable.\n\n    This function can be used as a Jinja2 filter in templates.\n\n    Example:\n        ```python\n        make_it_nolinebreak(\"Hello World!\", \"Hello\")\n        ```\n\n        will return:\n\n        `#!python \"\\\\mbox{Hello} World!\"`\n\n    Args:\n        value (str): The string to disable line breaks.\n        match_str (str): The string to match.\n    Returns:\n        str: The string with the matched part non line breakable.\n    \"\"\"\n    return make_matched_part_something(value, \"mbox\", match_str)\n</code></pre>"},{"location":"reference/renderer/#rendercv.renderer.abbreviate_name","title":"<code>abbreviate_name(name)</code>","text":"<p>Abbreviate a name by keeping the first letters of the first names.</p> <p>This function can be used as a Jinja2 filter in templates.</p> Example <pre><code>abbreviate_name(\"John Doe\")\n</code></pre> <p>will return:</p> <p><code>\"J. Doe\"</code></p> <p>Parameters:</p> <ul> <li> <code>name</code>             (<code>str</code>)         \u2013          <p>The name to abbreviate.</p> </li> </ul> <p>Returns:     str: The abbreviated name.</p> Source code in <code>rendercv/renderer.py</code> <pre><code>def abbreviate_name(name: Optional[str]) -&gt; str:\n    \"\"\"Abbreviate a name by keeping the first letters of the first names.\n\n    This function can be used as a Jinja2 filter in templates.\n\n    Example:\n        ```python\n        abbreviate_name(\"John Doe\")\n        ```\n\n        will return:\n\n        `#!python \"J. Doe\"`\n\n    Args:\n        name (str): The name to abbreviate.\n    Returns:\n        str: The abbreviated name.\n    \"\"\"\n    if name is None:\n        return \"\"\n\n    number_of_words = len(name.split(\" \"))\n\n    if number_of_words == 1:\n        return name\n\n    first_names = name.split(\" \")[:-1]\n    first_names_initials = [first_name[0] + \".\" for first_name in first_names]\n    last_name = name.split(\" \")[-1]\n    abbreviated_name = \" \".join(first_names_initials) + \" \" + last_name\n\n    return abbreviated_name\n</code></pre>"},{"location":"reference/renderer/#rendercv.renderer.divide_length_by","title":"<code>divide_length_by(length, divider)</code>","text":"<p>Divide a length by a number. Length is a string with the following regex pattern: <code>\\d+\\.?\\d* *(cm|in|pt|mm|ex|em)</code></p> <p>This function can be used as a Jinja2 filter in templates.</p> Example <pre><code>divide_length_by(\"10.4cm\", 2)\n</code></pre> <p>will return:</p> <p><code>\"5.2cm\"</code></p> <p>Parameters:</p> <ul> <li> <code>length</code>             (<code>str</code>)         \u2013          <p>The length to divide.</p> </li> <li> <code>divider</code>             (<code>float</code>)         \u2013          <p>The number to divide the length by.</p> </li> </ul> <p>Returns:     str: The divided length.</p> Source code in <code>rendercv/renderer.py</code> <pre><code>def divide_length_by(length: str, divider: float) -&gt; str:\n    r\"\"\"Divide a length by a number. Length is a string with the following regex\n    pattern: `\\d+\\.?\\d* *(cm|in|pt|mm|ex|em)`\n\n    This function can be used as a Jinja2 filter in templates.\n\n    Example:\n        ```python\n        divide_length_by(\"10.4cm\", 2)\n        ```\n\n        will return:\n\n        `#!python \"5.2cm\"`\n\n    Args:\n        length (str): The length to divide.\n        divider (float): The number to divide the length by.\n    Returns:\n        str: The divided length.\n    \"\"\"\n    # Get the value as a float and the unit as a string:\n    value = re.search(r\"\\d+\\.?\\d*\", length)\n\n    if value is None:\n        raise ValueError(f\"Invalid length {length}!\")\n    else:\n        value = value.group()\n\n    if divider &lt;= 0:\n        raise ValueError(f\"The divider must be greater than 0, but got {divider}!\")\n\n    unit = re.findall(r\"[^\\d\\.\\s]+\", length)[0]\n\n    return str(float(value) / divider) + \" \" + unit\n</code></pre>"},{"location":"reference/renderer/#rendercv.renderer.get_an_item_with_a_specific_attribute_value","title":"<code>get_an_item_with_a_specific_attribute_value(items, attribute, value)</code>","text":"<p>Get an item from a list of items with a specific attribute value.</p> <p>This function can be used as a Jinja2 filter in templates.</p> <p>Parameters:</p> <ul> <li> <code>items</code>             (<code>list[Any]</code>)         \u2013          <p>The list of items.</p> </li> <li> <code>attribute</code>             (<code>str</code>)         \u2013          <p>The attribute to check.</p> </li> <li> <code>value</code>             (<code>Any</code>)         \u2013          <p>The value of the attribute.</p> </li> </ul> <p>Returns:     Any: The item with the specific attribute value.</p> Source code in <code>rendercv/renderer.py</code> <pre><code>def get_an_item_with_a_specific_attribute_value(\n    items: Optional[list[Any]], attribute: str, value: Any\n) -&gt; Any:\n    \"\"\"Get an item from a list of items with a specific attribute value.\n\n    This function can be used as a Jinja2 filter in templates.\n\n    Args:\n        items (list[Any]): The list of items.\n        attribute (str): The attribute to check.\n        value (Any): The value of the attribute.\n    Returns:\n        Any: The item with the specific attribute value.\n    \"\"\"\n    if items is not None:\n        for item in items:\n            if not hasattr(item, attribute):\n                raise AttributeError(\n                    f\"The attribute {attribute} doesn't exist in the item {item}!\"\n                )\n            else:\n                if getattr(item, attribute) == value:\n                    return item\n\n    return None\n</code></pre>"},{"location":"reference/renderer/#rendercv.renderer.setup_jinja2_environment","title":"<code>setup_jinja2_environment()</code>","text":"<p>Setup and return the Jinja2 environment for templating the $\\LaTeX$ files.</p> <p>Returns:</p> <ul> <li> <code>Environment</code>         \u2013          <p>jinja2.Environment: The theme environment.</p> </li> </ul> Source code in <code>rendercv/renderer.py</code> <pre><code>def setup_jinja2_environment() -&gt; jinja2.Environment:\n    \"\"\"Setup and return the Jinja2 environment for templating the $\\\\LaTeX$ files.\n\n    Returns:\n        jinja2.Environment: The theme environment.\n    \"\"\"\n    # create a Jinja2 environment:\n    # we need to add the current working directory because custom themes might be used.\n    themes_directory = pathlib.Path(__file__).parent / \"themes\"\n    environment = jinja2.Environment(\n        loader=jinja2.FileSystemLoader([os.getcwd(), themes_directory]),\n        trim_blocks=True,\n        lstrip_blocks=True,\n    )\n\n    # set custom delimiters for LaTeX templating:\n    environment.block_start_string = \"((*\"\n    environment.block_end_string = \"*))\"\n    environment.variable_start_string = \"&lt;&lt;\"\n    environment.variable_end_string = \"&gt;&gt;\"\n    environment.comment_start_string = \"((#\"\n    environment.comment_end_string = \"#))\"\n\n    # add custom filters to make it easier to template the LaTeX files and add new\n    # themes:\n    environment.filters[\"make_it_bold\"] = make_matched_part_bold\n    environment.filters[\"make_it_underlined\"] = make_matched_part_underlined\n    environment.filters[\"make_it_italic\"] = make_matched_part_italic\n    environment.filters[\"make_it_nolinebreak\"] = make_matched_part_non_line_breakable\n    environment.filters[\"make_it_something\"] = make_matched_part_something\n    environment.filters[\"divide_length_by\"] = divide_length_by\n    environment.filters[\"abbreviate_name\"] = abbreviate_name\n    environment.filters[\"replace_placeholders_with_actual_values\"] = (\n        replace_placeholders_with_actual_values\n    )\n    environment.filters[\"get_an_item_with_a_specific_attribute_value\"] = (\n        get_an_item_with_a_specific_attribute_value\n    )\n    environment.filters[\"escape_latex_characters\"] = escape_latex_characters\n\n    return environment\n</code></pre>"},{"location":"reference/renderer/#rendercv.renderer.generate_latex_file","title":"<code>generate_latex_file(rendercv_data_model, output_directory)</code>","text":"<p>Generate the $\\LaTeX$ file with the given data model and write it to the output directory.</p> <p>Parameters:</p> <ul> <li> <code>rendercv_data_model</code>             (<code>RenderCVDataModel</code>)         \u2013          <p>The data model.</p> </li> <li> <code>output_directory</code>             (<code>Path</code>)         \u2013          <p>Path to the output directory.</p> </li> </ul> <p>Returns:     pathlib.Path: The path to the generated $\\LaTeX$ file.</p> Source code in <code>rendercv/renderer.py</code> <pre><code>def generate_latex_file(\n    rendercv_data_model: dm.RenderCVDataModel, output_directory: pathlib.Path\n) -&gt; pathlib.Path:\n    \"\"\"Generate the $\\\\LaTeX$ file with the given data model and write it to the output\n    directory.\n\n    Args:\n        rendercv_data_model (dm.RenderCVDataModel): The data model.\n        output_directory (pathlib.Path): Path to the output directory.\n    Returns:\n        pathlib.Path: The path to the generated $\\\\LaTeX$ file.\n    \"\"\"\n    # create output directory if it doesn't exist:\n    if not output_directory.is_dir():\n        output_directory.mkdir(parents=True)\n\n    jinja2_environment = setup_jinja2_environment()\n    latex_file_object = LaTeXFile(\n        rendercv_data_model,\n        jinja2_environment,\n    )\n\n    latex_file_name = f\"{str(rendercv_data_model.cv.name).replace(' ', '_')}_CV.tex\"\n    latex_file_path = output_directory / latex_file_name\n    latex_file_object.generate_latex_file(latex_file_path)\n\n    return latex_file_path\n</code></pre>"},{"location":"reference/renderer/#rendercv.renderer.generate_markdown_file","title":"<code>generate_markdown_file(rendercv_data_model, output_directory)</code>","text":"<p>Generate the Markdown file with the given data model and write it to the output directory.</p> <p>Parameters:</p> <ul> <li> <code>rendercv_data_model</code>             (<code>RenderCVDataModel</code>)         \u2013          <p>The data model.</p> </li> <li> <code>output_directory</code>             (<code>Path</code>)         \u2013          <p>Path to the output directory.</p> </li> </ul> <p>Returns:     pathlib.Path: The path to the generated Markdown file.</p> Source code in <code>rendercv/renderer.py</code> <pre><code>def generate_markdown_file(\n    rendercv_data_model: dm.RenderCVDataModel, output_directory: pathlib.Path\n) -&gt; pathlib.Path:\n    \"\"\"Generate the Markdown file with the given data model and write it to the output\n    directory.\n\n    Args:\n        rendercv_data_model (dm.RenderCVDataModel): The data model.\n        output_directory (pathlib.Path): Path to the output directory.\n    Returns:\n        pathlib.Path: The path to the generated Markdown file.\n    \"\"\"\n    # create output directory if it doesn't exist:\n    if not output_directory.is_dir():\n        output_directory.mkdir(parents=True)\n\n    jinja2_environment = setup_jinja2_environment()\n    markdown_file_object = MarkdownFile(\n        rendercv_data_model,\n        jinja2_environment,\n    )\n\n    markdown_file_name = f\"{str(rendercv_data_model.cv.name).replace(' ', '_')}_CV.md\"\n    markdown_file_path = output_directory / markdown_file_name\n    markdown_file_object.generate_markdown_file(markdown_file_path)\n\n    return markdown_file_path\n</code></pre>"},{"location":"reference/renderer/#rendercv.renderer.copy_theme_files_to_output_directory","title":"<code>copy_theme_files_to_output_directory(theme_name, output_directory_path, theme_directory_path=None)</code>","text":"<p>Copy the auxiliary files (all the files that don't end with <code>.j2.tex</code> and <code>.py</code>) of the theme to the output directory. For example, the \"classic\" theme has custom fonts, and the $\\LaTeX$ needs it. If the theme is a custom theme, then it will be copied from the current working directory.</p> <p>Parameters:</p> <ul> <li> <code>theme_name</code>             (<code>str</code>)         \u2013          <p>The name of the theme.</p> </li> <li> <code>output_directory</code>             (<code>Path</code>)         \u2013          <p>Path to the output directory.</p> </li> </ul> Source code in <code>rendercv/renderer.py</code> <pre><code>def copy_theme_files_to_output_directory(\n    theme_name: str,\n    output_directory_path: pathlib.Path,\n    theme_directory_path: Optional[pathlib.Path] = None,\n):\n    \"\"\"Copy the auxiliary files (all the files that don't end with `.j2.tex` and `.py`)\n    of the theme to the output directory. For example, the \"classic\" theme has custom\n    fonts, and the $\\\\LaTeX$ needs it. If the theme is a custom theme, then it will be\n    copied from the current working directory.\n\n    Args:\n        theme_name (str): The name of the theme.\n        output_directory (pathlib.Path): Path to the output directory.\n    \"\"\"\n    if theme_directory_path is None:\n        if theme_name in dm.available_themes:\n            theme_directory_path = importlib.resources.files(\n                f\"rendercv.themes.{theme_name}\"\n            )\n        else:\n            # Then it means the theme is a custom theme. If theme_directory is not given\n            # as an argument, then look for the theme in the current working directory.\n            theme_directory_path = pathlib.Path(os.getcwd()) / theme_name\n\n            if not theme_directory_path.is_dir():\n                raise FileNotFoundError(\n                    f\"The theme {theme_name} doesn't exist in the current working\"\n                    \" directory!\"\n                )\n\n    for theme_file in theme_directory_path.iterdir():\n        dont_copy_files_with_these_extensions = [\".j2.tex\", \".py\"]\n        # theme_file.suffix returns the latest part of the file name after the last dot.\n        # But we need the latest part of the file name after the first dot:\n        try:\n            suffix = re.search(r\"\\..*\", theme_file.name)[0]\n        except TypeError:\n            suffix = \"\"\n\n        if suffix not in dont_copy_files_with_these_extensions:\n            if theme_file.is_dir():\n                shutil.copytree(\n                    str(theme_file),\n                    output_directory_path / theme_file.name,\n                    dirs_exist_ok=True,\n                )\n            else:\n                shutil.copyfile(\n                    str(theme_file), output_directory_path / theme_file.name\n                )\n</code></pre>"},{"location":"reference/renderer/#rendercv.renderer.generate_latex_file_and_copy_theme_files","title":"<code>generate_latex_file_and_copy_theme_files(rendercv_data_model, output_directory)</code>","text":"<p>Generate the $\\LaTeX$ file with the given data model in the output directory and copy the auxiliary theme files to the output directory.</p> <p>Parameters:</p> <ul> <li> <code>rendercv_data_model</code>             (<code>RenderCVDataModel</code>)         \u2013          <p>The data model.</p> </li> <li> <code>output_directory</code>             (<code>Path</code>)         \u2013          <p>Path to the output directory.</p> </li> </ul> <p>Returns:     pathlib.Path: The path to the generated $\\LaTeX$ file.</p> Source code in <code>rendercv/renderer.py</code> <pre><code>def generate_latex_file_and_copy_theme_files(\n    rendercv_data_model: dm.RenderCVDataModel, output_directory: pathlib.Path\n) -&gt; pathlib.Path:\n    \"\"\"Generate the $\\\\LaTeX$ file with the given data model in the output directory and\n    copy the auxiliary theme files to the output directory.\n\n    Args:\n        rendercv_data_model (dm.RenderCVDataModel): The data model.\n        output_directory (pathlib.Path): Path to the output directory.\n    Returns:\n        pathlib.Path: The path to the generated $\\\\LaTeX$ file.\n    \"\"\"\n    latex_file_path = generate_latex_file(rendercv_data_model, output_directory)\n    copy_theme_files_to_output_directory(\n        rendercv_data_model.design.theme, output_directory\n    )\n    return latex_file_path\n</code></pre>"},{"location":"reference/renderer/#rendercv.renderer.latex_to_pdf","title":"<code>latex_to_pdf(latex_file_path, local_latex_command=None)</code>","text":"<p>Run TinyTeX with the given $\\LaTeX$ file to generate the PDF.</p> <p>Parameters:</p> <ul> <li> <code>latex_file_path</code>             (<code>str</code>)         \u2013          <p>The path to the $\\LaTeX$ file to compile.</p> </li> </ul> <p>Returns:     pathlib.Path: The path to the generated PDF file.</p> Source code in <code>rendercv/renderer.py</code> <pre><code>def latex_to_pdf(\n    latex_file_path: pathlib.Path, local_latex_command: Optional[str] = None\n) -&gt; pathlib.Path:\n    \"\"\"Run TinyTeX with the given $\\\\LaTeX$ file to generate the PDF.\n\n    Args:\n        latex_file_path (str): The path to the $\\\\LaTeX$ file to compile.\n    Returns:\n        pathlib.Path: The path to the generated PDF file.\n    \"\"\"\n    # check if the file exists:\n    if not latex_file_path.is_file():\n        raise FileNotFoundError(f\"The file {latex_file_path} doesn't exist!\")\n\n    if local_latex_command:\n        executable = local_latex_command\n\n        # check if the command is working:\n        try:\n            subprocess.run(\n                [executable, \"--version\"],\n                stdout=subprocess.DEVNULL,  # don't capture the output\n                stderr=subprocess.DEVNULL,  # don't capture the error\n            )\n        except FileNotFoundError:\n            raise FileNotFoundError(\n                f\"[blue]{executable}[/blue] isn't installed! Please install LaTeX and\"\n                \" try again (or don't use the\"\n                \" [bright_black]--use-local-latex-command[/bright_black] option).\"\n            )\n    else:\n        tinytex_binaries_directory = (\n            pathlib.Path(__file__).parent / \"tinytex-release\" / \"TinyTeX\" / \"bin\"\n        )\n\n        executables = {\n            \"win32\": tinytex_binaries_directory / \"windows\" / \"pdflatex.exe\",\n            \"linux\": tinytex_binaries_directory / \"x86_64-linux\" / \"pdflatex\",\n            \"darwin\": tinytex_binaries_directory / \"universal-darwin\" / \"pdflatex\",\n        }\n\n        if sys.platform not in executables:\n            raise OSError(f\"TinyTeX doesn't support the platform {sys.platform}!\")\n\n        executable = executables[sys.platform]\n    # Run TinyTeX:\n    command = [\n        executable,\n        str(latex_file_path.absolute()),\n    ]\n    with subprocess.Popen(\n        command,\n        cwd=latex_file_path.parent,\n        stdout=subprocess.PIPE,  # capture the output\n        stderr=subprocess.DEVNULL,  # don't capture the error\n        stdin=subprocess.DEVNULL,  # don't allow TinyTeX to ask for user input\n    ) as latex_process:\n        output = latex_process.communicate()  # wait for the process to finish\n        if latex_process.returncode != 0:\n            raise RuntimeError(\n                \"Running TinyTeX has failed! For debugging, we suggest running the\"\n                \" LaTeX file manually in https://overleaf.com.\",\n                \"If you want to run it locally, run the command below in the terminal:\",\n                \" \".join([str(command_part) for command_part in command]),\n                \"If you can't solve the problem, please open an issue on GitHub.\",\n            )\n        else:\n            try:\n                output = output[0].decode(\"utf-8\")\n            except UnicodeDecodeError:\n                output = output[0].decode(\"latin-1\")\n\n            if \"Rerun to get\" in output:\n                # Run TinyTeX again to get the references right:\n                subprocess.run(\n                    command,\n                    cwd=latex_file_path.parent,\n                    stdout=subprocess.DEVNULL,  # don't capture the output\n                    stderr=subprocess.DEVNULL,  # don't capture the error\n                    stdin=subprocess.DEVNULL,  # don't allow TinyTeX to ask for user input\n                )\n\n    # check if the PDF file is generated:\n    pdf_file_path = latex_file_path.with_suffix(\".pdf\")\n    if not pdf_file_path.is_file():\n        raise RuntimeError(\n            \"The PDF file couldn't be generated! If you can't solve the problem,\"\n            \" please try to re-install RenderCV, or open an issue on GitHub.\"\n        )\n\n    return pdf_file_path\n</code></pre>"},{"location":"reference/renderer/#rendercv.renderer.markdown_to_html","title":"<code>markdown_to_html(markdown_file_path)</code>","text":"<p>Convert a markdown file to HTML.</p> <p>RenderCV doesn't produce an HTML file as the final output, but generates it for users to easily copy and paste the HTML into Grammarly for proofreading purposes.</p> <p>Parameters:</p> <ul> <li> <code>markdown_file_path</code>             (<code>Path</code>)         \u2013          <p>The path to the markdown file to convert.</p> </li> </ul> <p>Returns:     pathlib.Path: The path to the generated HTML file.</p> Source code in <code>rendercv/renderer.py</code> <pre><code>def markdown_to_html(markdown_file_path: pathlib.Path) -&gt; pathlib.Path:\n    \"\"\"Convert a markdown file to HTML.\n\n    RenderCV doesn't produce an HTML file as the final output, but generates it for\n    users to easily copy and paste the HTML into Grammarly for proofreading purposes.\n\n    Args:\n        markdown_file_path (pathlib.Path): The path to the markdown file to convert.\n    Returns:\n        pathlib.Path: The path to the generated HTML file.\n    \"\"\"\n    # check if the file exists:\n    if not markdown_file_path.is_file():\n        raise FileNotFoundError(f\"The file {markdown_file_path} doesn't exist!\")\n\n    html_file_path = (\n        markdown_file_path.parent / f\"{markdown_file_path.stem}_PASTETOGRAMMARLY.html\"\n    )\n\n    # Convert the markdown file to HTML:\n    html = markdown.markdown(markdown_file_path.read_text(encoding=\"utf-8\"))\n\n    # write html into a file:\n    html_file_path.write_text(html, encoding=\"utf-8\")\n\n    return html_file_path\n</code></pre>"},{"location":"reference/themes/","title":"Themes","text":"<p>This module containts some general-purpose data models for the themes. The themes are encouraged to inherit from these data models and add their own options, to avoid code duplication.</p>"},{"location":"reference/themes/#rendercv.themes.PageMargins","title":"<code>PageMargins</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>This class is a data model for the page margins.</p>"},{"location":"reference/themes/#rendercv.themes.SectionTitleMargins","title":"<code>SectionTitleMargins</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>This class is a data model for the section title margins.</p>"},{"location":"reference/themes/#rendercv.themes.EntryAreaMargins","title":"<code>EntryAreaMargins</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>This class is a data model for the entry area margins.</p>"},{"location":"reference/themes/#rendercv.themes.HighlightsAreaMargins","title":"<code>HighlightsAreaMargins</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>This class is a data model for the highlights area margins.</p>"},{"location":"reference/themes/#rendercv.themes.HeaderMargins","title":"<code>HeaderMargins</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>This class is a data model for the header margins.</p>"},{"location":"reference/themes/#rendercv.themes.Margins","title":"<code>Margins</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>This class is a data model for the margins.</p>"},{"location":"reference/themes/#rendercv.themes.ThemeOptions","title":"<code>ThemeOptions</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>This class is a generic data model for the theme options. The themes are encouraged to inherit from this data model and add their own options, to avoid code duplication.</p>"},{"location":"reference/themes/classic/","title":"Classic Theme","text":""},{"location":"reference/themes/classic/#rendercv.themes.classic.ClassicThemeOptions","title":"<code>ClassicThemeOptions</code>","text":"<p>             Bases: <code>ThemeOptions</code></p> <p>This class is the data model of the theme options for the <code>classic</code> theme.</p>"},{"location":"reference/themes/moderncv/","title":"Moderncv Theme","text":""},{"location":"reference/themes/moderncv/#rendercv.themes.moderncv.ModerncvThemeOptions","title":"<code>ModerncvThemeOptions</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>This class is the data model of the theme options for the <code>moderncv</code> theme.</p>"},{"location":"reference/themes/sb2nov/","title":"Sb2nov Theme","text":""},{"location":"reference/themes/sb2nov/#rendercv.themes.sb2nov.Sb2novThemeOptions","title":"<code>Sb2novThemeOptions</code>","text":"<p>             Bases: <code>ThemeOptions</code></p> <p>This class is the data model of the theme options for the sb2nov theme.</p>"}]}